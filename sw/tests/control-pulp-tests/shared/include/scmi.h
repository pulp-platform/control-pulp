// Generated register defines for scmi

// Copyright information found in source file:
// Copyright lowRISC contributors.

// Licensing information found in source file:
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#ifndef _SCMI_REG_DEFS_
#define _SCMI_REG_DEFS_

#ifdef __cplusplus
extern "C" {
#endif
// Register width
#define SCMI_PARAM_REG_WIDTH 32

// Reserved, must be 0
#define SCMI_RESERVED_1_C0_REG_OFFSET 0x0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C0_REG_OFFSET 0x4
#define SCMI_CHANNEL_STATUS_C0_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C0_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C0_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C0_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C0_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C0_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C0_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C0_REG_OFFSET 0x8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C0_REG_OFFSET 0xc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C0_REG_OFFSET 0x10
#define SCMI_CHANNEL_FLAGS_C0_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C0_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C0_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C0_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C0_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C0_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C0_REG_OFFSET 0x14

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C0_REG_OFFSET 0x18
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C0_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C0_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C0_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C0_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C0_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C0_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C0_REG_OFFSET 0x1c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C0_REG_OFFSET 0x20
#define SCMI_DOORBELL_C0_INTR_BIT 0
#define SCMI_DOORBELL_C0_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C0_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C0_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C0_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C0_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C0_REG_OFFSET 0x24
#define SCMI_COMPLETION_INTERRUPT_C0_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C1_REG_OFFSET 0x28

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C1_REG_OFFSET 0x2c
#define SCMI_CHANNEL_STATUS_C1_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C1_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C1_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C1_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C1_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C1_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C1_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C1_REG_OFFSET 0x30

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C1_REG_OFFSET 0x34

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C1_REG_OFFSET 0x38
#define SCMI_CHANNEL_FLAGS_C1_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C1_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C1_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C1_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C1_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C1_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C1_REG_OFFSET 0x3c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C1_REG_OFFSET 0x40
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C1_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C1_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C1_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C1_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C1_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C1_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C1_REG_OFFSET 0x44

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C1_REG_OFFSET 0x48
#define SCMI_DOORBELL_C1_INTR_BIT 0
#define SCMI_DOORBELL_C1_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C1_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C1_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C1_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C1_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C1_REG_OFFSET 0x4c
#define SCMI_COMPLETION_INTERRUPT_C1_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C2_REG_OFFSET 0x50

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C2_REG_OFFSET 0x54
#define SCMI_CHANNEL_STATUS_C2_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C2_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C2_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C2_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C2_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C2_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C2_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C2_REG_OFFSET 0x58

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C2_REG_OFFSET 0x5c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C2_REG_OFFSET 0x60
#define SCMI_CHANNEL_FLAGS_C2_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C2_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C2_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C2_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C2_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C2_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C2_REG_OFFSET 0x64

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C2_REG_OFFSET 0x68
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C2_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C2_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C2_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C2_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C2_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C2_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C2_REG_OFFSET 0x6c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C2_REG_OFFSET 0x70
#define SCMI_DOORBELL_C2_INTR_BIT 0
#define SCMI_DOORBELL_C2_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C2_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C2_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C2_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C2_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C2_REG_OFFSET 0x74
#define SCMI_COMPLETION_INTERRUPT_C2_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C3_REG_OFFSET 0x78

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C3_REG_OFFSET 0x7c
#define SCMI_CHANNEL_STATUS_C3_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C3_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C3_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C3_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C3_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C3_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C3_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C3_REG_OFFSET 0x80

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C3_REG_OFFSET 0x84

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C3_REG_OFFSET 0x88
#define SCMI_CHANNEL_FLAGS_C3_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C3_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C3_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C3_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C3_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C3_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C3_REG_OFFSET 0x8c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C3_REG_OFFSET 0x90
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C3_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C3_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C3_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C3_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C3_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C3_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C3_REG_OFFSET 0x94

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C3_REG_OFFSET 0x98
#define SCMI_DOORBELL_C3_INTR_BIT 0
#define SCMI_DOORBELL_C3_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C3_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C3_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C3_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C3_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C3_REG_OFFSET 0x9c
#define SCMI_COMPLETION_INTERRUPT_C3_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C4_REG_OFFSET 0xa0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C4_REG_OFFSET 0xa4
#define SCMI_CHANNEL_STATUS_C4_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C4_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C4_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C4_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C4_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C4_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C4_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C4_REG_OFFSET 0xa8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C4_REG_OFFSET 0xac

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C4_REG_OFFSET 0xb0
#define SCMI_CHANNEL_FLAGS_C4_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C4_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C4_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C4_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C4_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C4_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C4_REG_OFFSET 0xb4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C4_REG_OFFSET 0xb8
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C4_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C4_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C4_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C4_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C4_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C4_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C4_REG_OFFSET 0xbc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C4_REG_OFFSET 0xc0
#define SCMI_DOORBELL_C4_INTR_BIT 0
#define SCMI_DOORBELL_C4_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C4_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C4_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C4_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C4_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C4_REG_OFFSET 0xc4
#define SCMI_COMPLETION_INTERRUPT_C4_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C5_REG_OFFSET 0xc8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C5_REG_OFFSET 0xcc
#define SCMI_CHANNEL_STATUS_C5_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C5_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C5_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C5_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C5_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C5_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C5_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C5_REG_OFFSET 0xd0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C5_REG_OFFSET 0xd4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C5_REG_OFFSET 0xd8
#define SCMI_CHANNEL_FLAGS_C5_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C5_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C5_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C5_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C5_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C5_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C5_REG_OFFSET 0xdc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C5_REG_OFFSET 0xe0
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C5_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C5_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C5_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C5_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C5_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C5_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C5_REG_OFFSET 0xe4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C5_REG_OFFSET 0xe8
#define SCMI_DOORBELL_C5_INTR_BIT 0
#define SCMI_DOORBELL_C5_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C5_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C5_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C5_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C5_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C5_REG_OFFSET 0xec
#define SCMI_COMPLETION_INTERRUPT_C5_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C6_REG_OFFSET 0xf0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C6_REG_OFFSET 0xf4
#define SCMI_CHANNEL_STATUS_C6_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C6_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C6_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C6_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C6_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C6_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C6_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C6_REG_OFFSET 0xf8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C6_REG_OFFSET 0xfc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C6_REG_OFFSET 0x100
#define SCMI_CHANNEL_FLAGS_C6_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C6_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C6_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C6_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C6_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C6_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C6_REG_OFFSET 0x104

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C6_REG_OFFSET 0x108
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C6_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C6_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C6_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C6_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C6_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C6_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C6_REG_OFFSET 0x10c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C6_REG_OFFSET 0x110
#define SCMI_DOORBELL_C6_INTR_BIT 0
#define SCMI_DOORBELL_C6_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C6_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C6_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C6_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C6_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C6_REG_OFFSET 0x114
#define SCMI_COMPLETION_INTERRUPT_C6_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C7_REG_OFFSET 0x118

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C7_REG_OFFSET 0x11c
#define SCMI_CHANNEL_STATUS_C7_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C7_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C7_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C7_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C7_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C7_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C7_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C7_REG_OFFSET 0x120

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C7_REG_OFFSET 0x124

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C7_REG_OFFSET 0x128
#define SCMI_CHANNEL_FLAGS_C7_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C7_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C7_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C7_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C7_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C7_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C7_REG_OFFSET 0x12c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C7_REG_OFFSET 0x130
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C7_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C7_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C7_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C7_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C7_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C7_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C7_REG_OFFSET 0x134

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C7_REG_OFFSET 0x138
#define SCMI_DOORBELL_C7_INTR_BIT 0
#define SCMI_DOORBELL_C7_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C7_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C7_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C7_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C7_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C7_REG_OFFSET 0x13c
#define SCMI_COMPLETION_INTERRUPT_C7_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C8_REG_OFFSET 0x140

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C8_REG_OFFSET 0x144
#define SCMI_CHANNEL_STATUS_C8_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C8_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C8_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C8_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C8_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C8_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C8_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C8_REG_OFFSET 0x148

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C8_REG_OFFSET 0x14c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C8_REG_OFFSET 0x150
#define SCMI_CHANNEL_FLAGS_C8_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C8_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C8_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C8_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C8_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C8_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C8_REG_OFFSET 0x154

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C8_REG_OFFSET 0x158
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C8_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C8_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C8_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C8_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C8_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C8_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C8_REG_OFFSET 0x15c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C8_REG_OFFSET 0x160
#define SCMI_DOORBELL_C8_INTR_BIT 0
#define SCMI_DOORBELL_C8_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C8_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C8_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C8_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C8_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C8_REG_OFFSET 0x164
#define SCMI_COMPLETION_INTERRUPT_C8_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C9_REG_OFFSET 0x168

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C9_REG_OFFSET 0x16c
#define SCMI_CHANNEL_STATUS_C9_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C9_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C9_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C9_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C9_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C9_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C9_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C9_REG_OFFSET 0x170

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C9_REG_OFFSET 0x174

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C9_REG_OFFSET 0x178
#define SCMI_CHANNEL_FLAGS_C9_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C9_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C9_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C9_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C9_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C9_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C9_REG_OFFSET 0x17c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C9_REG_OFFSET 0x180
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C9_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C9_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C9_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C9_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C9_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C9_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C9_REG_OFFSET 0x184

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C9_REG_OFFSET 0x188
#define SCMI_DOORBELL_C9_INTR_BIT 0
#define SCMI_DOORBELL_C9_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C9_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C9_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C9_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C9_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C9_REG_OFFSET 0x18c
#define SCMI_COMPLETION_INTERRUPT_C9_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C10_REG_OFFSET 0x190

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C10_REG_OFFSET 0x194
#define SCMI_CHANNEL_STATUS_C10_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C10_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C10_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C10_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C10_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C10_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C10_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C10_REG_OFFSET 0x198

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C10_REG_OFFSET 0x19c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C10_REG_OFFSET 0x1a0
#define SCMI_CHANNEL_FLAGS_C10_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C10_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C10_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C10_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C10_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C10_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C10_REG_OFFSET 0x1a4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C10_REG_OFFSET 0x1a8
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C10_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C10_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C10_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C10_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C10_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C10_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C10_REG_OFFSET 0x1ac

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C10_REG_OFFSET 0x1b0
#define SCMI_DOORBELL_C10_INTR_BIT 0
#define SCMI_DOORBELL_C10_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C10_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C10_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C10_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C10_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C10_REG_OFFSET 0x1b4
#define SCMI_COMPLETION_INTERRUPT_C10_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C11_REG_OFFSET 0x1b8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C11_REG_OFFSET 0x1bc
#define SCMI_CHANNEL_STATUS_C11_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C11_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C11_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C11_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C11_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C11_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C11_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C11_REG_OFFSET 0x1c0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C11_REG_OFFSET 0x1c4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C11_REG_OFFSET 0x1c8
#define SCMI_CHANNEL_FLAGS_C11_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C11_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C11_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C11_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C11_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C11_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C11_REG_OFFSET 0x1cc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C11_REG_OFFSET 0x1d0
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C11_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C11_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C11_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C11_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C11_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C11_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C11_REG_OFFSET 0x1d4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C11_REG_OFFSET 0x1d8
#define SCMI_DOORBELL_C11_INTR_BIT 0
#define SCMI_DOORBELL_C11_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C11_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C11_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C11_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C11_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C11_REG_OFFSET 0x1dc
#define SCMI_COMPLETION_INTERRUPT_C11_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C12_REG_OFFSET 0x1e0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C12_REG_OFFSET 0x1e4
#define SCMI_CHANNEL_STATUS_C12_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C12_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C12_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C12_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C12_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C12_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C12_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C12_REG_OFFSET 0x1e8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C12_REG_OFFSET 0x1ec

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C12_REG_OFFSET 0x1f0
#define SCMI_CHANNEL_FLAGS_C12_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C12_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C12_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C12_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C12_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C12_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C12_REG_OFFSET 0x1f4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C12_REG_OFFSET 0x1f8
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C12_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C12_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C12_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C12_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C12_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C12_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C12_REG_OFFSET 0x1fc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C12_REG_OFFSET 0x200
#define SCMI_DOORBELL_C12_INTR_BIT 0
#define SCMI_DOORBELL_C12_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C12_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C12_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C12_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C12_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C12_REG_OFFSET 0x204
#define SCMI_COMPLETION_INTERRUPT_C12_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C13_REG_OFFSET 0x208

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C13_REG_OFFSET 0x20c
#define SCMI_CHANNEL_STATUS_C13_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C13_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C13_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C13_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C13_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C13_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C13_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C13_REG_OFFSET 0x210

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C13_REG_OFFSET 0x214

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C13_REG_OFFSET 0x218
#define SCMI_CHANNEL_FLAGS_C13_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C13_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C13_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C13_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C13_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C13_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C13_REG_OFFSET 0x21c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C13_REG_OFFSET 0x220
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C13_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C13_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C13_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C13_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C13_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C13_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C13_REG_OFFSET 0x224

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C13_REG_OFFSET 0x228
#define SCMI_DOORBELL_C13_INTR_BIT 0
#define SCMI_DOORBELL_C13_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C13_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C13_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C13_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C13_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C13_REG_OFFSET 0x22c
#define SCMI_COMPLETION_INTERRUPT_C13_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C14_REG_OFFSET 0x230

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C14_REG_OFFSET 0x234
#define SCMI_CHANNEL_STATUS_C14_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C14_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C14_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C14_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C14_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C14_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C14_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C14_REG_OFFSET 0x238

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C14_REG_OFFSET 0x23c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C14_REG_OFFSET 0x240
#define SCMI_CHANNEL_FLAGS_C14_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C14_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C14_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C14_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C14_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C14_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C14_REG_OFFSET 0x244

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C14_REG_OFFSET 0x248
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C14_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C14_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C14_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C14_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C14_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C14_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C14_REG_OFFSET 0x24c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C14_REG_OFFSET 0x250
#define SCMI_DOORBELL_C14_INTR_BIT 0
#define SCMI_DOORBELL_C14_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C14_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C14_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C14_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C14_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C14_REG_OFFSET 0x254
#define SCMI_COMPLETION_INTERRUPT_C14_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C15_REG_OFFSET 0x258

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C15_REG_OFFSET 0x25c
#define SCMI_CHANNEL_STATUS_C15_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C15_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C15_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C15_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C15_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C15_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C15_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C15_REG_OFFSET 0x260

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C15_REG_OFFSET 0x264

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C15_REG_OFFSET 0x268
#define SCMI_CHANNEL_FLAGS_C15_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C15_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C15_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C15_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C15_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C15_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C15_REG_OFFSET 0x26c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C15_REG_OFFSET 0x270
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C15_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C15_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C15_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C15_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C15_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C15_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C15_REG_OFFSET 0x274

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C15_REG_OFFSET 0x278
#define SCMI_DOORBELL_C15_INTR_BIT 0
#define SCMI_DOORBELL_C15_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C15_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C15_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C15_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C15_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C15_REG_OFFSET 0x27c
#define SCMI_COMPLETION_INTERRUPT_C15_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C16_REG_OFFSET 0x280

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C16_REG_OFFSET 0x284
#define SCMI_CHANNEL_STATUS_C16_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C16_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C16_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C16_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C16_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C16_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C16_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C16_REG_OFFSET 0x288

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C16_REG_OFFSET 0x28c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C16_REG_OFFSET 0x290
#define SCMI_CHANNEL_FLAGS_C16_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C16_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C16_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C16_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C16_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C16_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C16_REG_OFFSET 0x294

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C16_REG_OFFSET 0x298
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C16_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C16_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C16_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C16_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C16_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C16_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C16_REG_OFFSET 0x29c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C16_REG_OFFSET 0x2a0
#define SCMI_DOORBELL_C16_INTR_BIT 0
#define SCMI_DOORBELL_C16_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C16_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C16_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C16_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C16_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C16_REG_OFFSET 0x2a4
#define SCMI_COMPLETION_INTERRUPT_C16_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C17_REG_OFFSET 0x2a8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C17_REG_OFFSET 0x2ac
#define SCMI_CHANNEL_STATUS_C17_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C17_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C17_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C17_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C17_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C17_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C17_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C17_REG_OFFSET 0x2b0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C17_REG_OFFSET 0x2b4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C17_REG_OFFSET 0x2b8
#define SCMI_CHANNEL_FLAGS_C17_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C17_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C17_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C17_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C17_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C17_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C17_REG_OFFSET 0x2bc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C17_REG_OFFSET 0x2c0
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C17_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C17_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C17_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C17_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C17_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C17_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C17_REG_OFFSET 0x2c4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C17_REG_OFFSET 0x2c8
#define SCMI_DOORBELL_C17_INTR_BIT 0
#define SCMI_DOORBELL_C17_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C17_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C17_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C17_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C17_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C17_REG_OFFSET 0x2cc
#define SCMI_COMPLETION_INTERRUPT_C17_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C18_REG_OFFSET 0x2d0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C18_REG_OFFSET 0x2d4
#define SCMI_CHANNEL_STATUS_C18_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C18_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C18_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C18_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C18_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C18_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C18_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C18_REG_OFFSET 0x2d8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C18_REG_OFFSET 0x2dc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C18_REG_OFFSET 0x2e0
#define SCMI_CHANNEL_FLAGS_C18_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C18_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C18_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C18_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C18_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C18_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C18_REG_OFFSET 0x2e4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C18_REG_OFFSET 0x2e8
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C18_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C18_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C18_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C18_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C18_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C18_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C18_REG_OFFSET 0x2ec

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C18_REG_OFFSET 0x2f0
#define SCMI_DOORBELL_C18_INTR_BIT 0
#define SCMI_DOORBELL_C18_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C18_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C18_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C18_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C18_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C18_REG_OFFSET 0x2f4
#define SCMI_COMPLETION_INTERRUPT_C18_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C19_REG_OFFSET 0x2f8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C19_REG_OFFSET 0x2fc
#define SCMI_CHANNEL_STATUS_C19_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C19_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C19_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C19_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C19_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C19_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C19_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C19_REG_OFFSET 0x300

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C19_REG_OFFSET 0x304

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C19_REG_OFFSET 0x308
#define SCMI_CHANNEL_FLAGS_C19_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C19_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C19_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C19_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C19_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C19_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C19_REG_OFFSET 0x30c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C19_REG_OFFSET 0x310
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C19_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C19_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C19_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C19_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C19_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C19_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C19_REG_OFFSET 0x314

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C19_REG_OFFSET 0x318
#define SCMI_DOORBELL_C19_INTR_BIT 0
#define SCMI_DOORBELL_C19_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C19_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C19_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C19_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C19_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C19_REG_OFFSET 0x31c
#define SCMI_COMPLETION_INTERRUPT_C19_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C20_REG_OFFSET 0x320

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C20_REG_OFFSET 0x324
#define SCMI_CHANNEL_STATUS_C20_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C20_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C20_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C20_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C20_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C20_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C20_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C20_REG_OFFSET 0x328

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C20_REG_OFFSET 0x32c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C20_REG_OFFSET 0x330
#define SCMI_CHANNEL_FLAGS_C20_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C20_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C20_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C20_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C20_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C20_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C20_REG_OFFSET 0x334

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C20_REG_OFFSET 0x338
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C20_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C20_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C20_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C20_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C20_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C20_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C20_REG_OFFSET 0x33c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C20_REG_OFFSET 0x340
#define SCMI_DOORBELL_C20_INTR_BIT 0
#define SCMI_DOORBELL_C20_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C20_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C20_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C20_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C20_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C20_REG_OFFSET 0x344
#define SCMI_COMPLETION_INTERRUPT_C20_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C21_REG_OFFSET 0x348

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C21_REG_OFFSET 0x34c
#define SCMI_CHANNEL_STATUS_C21_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C21_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C21_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C21_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C21_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C21_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C21_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C21_REG_OFFSET 0x350

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C21_REG_OFFSET 0x354

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C21_REG_OFFSET 0x358
#define SCMI_CHANNEL_FLAGS_C21_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C21_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C21_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C21_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C21_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C21_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C21_REG_OFFSET 0x35c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C21_REG_OFFSET 0x360
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C21_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C21_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C21_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C21_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C21_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C21_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C21_REG_OFFSET 0x364

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C21_REG_OFFSET 0x368
#define SCMI_DOORBELL_C21_INTR_BIT 0
#define SCMI_DOORBELL_C21_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C21_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C21_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C21_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C21_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C21_REG_OFFSET 0x36c
#define SCMI_COMPLETION_INTERRUPT_C21_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C22_REG_OFFSET 0x370

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C22_REG_OFFSET 0x374
#define SCMI_CHANNEL_STATUS_C22_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C22_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C22_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C22_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C22_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C22_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C22_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C22_REG_OFFSET 0x378

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C22_REG_OFFSET 0x37c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C22_REG_OFFSET 0x380
#define SCMI_CHANNEL_FLAGS_C22_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C22_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C22_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C22_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C22_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C22_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C22_REG_OFFSET 0x384

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C22_REG_OFFSET 0x388
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C22_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C22_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C22_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C22_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C22_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C22_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C22_REG_OFFSET 0x38c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C22_REG_OFFSET 0x390
#define SCMI_DOORBELL_C22_INTR_BIT 0
#define SCMI_DOORBELL_C22_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C22_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C22_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C22_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C22_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C22_REG_OFFSET 0x394
#define SCMI_COMPLETION_INTERRUPT_C22_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C23_REG_OFFSET 0x398

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C23_REG_OFFSET 0x39c
#define SCMI_CHANNEL_STATUS_C23_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C23_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C23_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C23_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C23_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C23_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C23_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C23_REG_OFFSET 0x3a0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C23_REG_OFFSET 0x3a4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C23_REG_OFFSET 0x3a8
#define SCMI_CHANNEL_FLAGS_C23_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C23_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C23_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C23_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C23_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C23_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C23_REG_OFFSET 0x3ac

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C23_REG_OFFSET 0x3b0
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C23_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C23_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C23_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C23_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C23_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C23_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C23_REG_OFFSET 0x3b4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C23_REG_OFFSET 0x3b8
#define SCMI_DOORBELL_C23_INTR_BIT 0
#define SCMI_DOORBELL_C23_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C23_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C23_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C23_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C23_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C23_REG_OFFSET 0x3bc
#define SCMI_COMPLETION_INTERRUPT_C23_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C24_REG_OFFSET 0x3c0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C24_REG_OFFSET 0x3c4
#define SCMI_CHANNEL_STATUS_C24_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C24_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C24_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C24_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C24_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C24_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C24_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C24_REG_OFFSET 0x3c8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C24_REG_OFFSET 0x3cc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C24_REG_OFFSET 0x3d0
#define SCMI_CHANNEL_FLAGS_C24_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C24_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C24_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C24_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C24_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C24_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C24_REG_OFFSET 0x3d4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C24_REG_OFFSET 0x3d8
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C24_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C24_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C24_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C24_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C24_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C24_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C24_REG_OFFSET 0x3dc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C24_REG_OFFSET 0x3e0
#define SCMI_DOORBELL_C24_INTR_BIT 0
#define SCMI_DOORBELL_C24_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C24_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C24_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C24_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C24_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C24_REG_OFFSET 0x3e4
#define SCMI_COMPLETION_INTERRUPT_C24_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C25_REG_OFFSET 0x3e8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C25_REG_OFFSET 0x3ec
#define SCMI_CHANNEL_STATUS_C25_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C25_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C25_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C25_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C25_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C25_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C25_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C25_REG_OFFSET 0x3f0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C25_REG_OFFSET 0x3f4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C25_REG_OFFSET 0x3f8
#define SCMI_CHANNEL_FLAGS_C25_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C25_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C25_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C25_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C25_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C25_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C25_REG_OFFSET 0x3fc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C25_REG_OFFSET 0x400
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C25_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C25_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C25_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C25_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C25_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C25_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C25_REG_OFFSET 0x404

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C25_REG_OFFSET 0x408
#define SCMI_DOORBELL_C25_INTR_BIT 0
#define SCMI_DOORBELL_C25_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C25_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C25_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C25_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C25_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C25_REG_OFFSET 0x40c
#define SCMI_COMPLETION_INTERRUPT_C25_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C26_REG_OFFSET 0x410

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C26_REG_OFFSET 0x414
#define SCMI_CHANNEL_STATUS_C26_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C26_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C26_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C26_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C26_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C26_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C26_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C26_REG_OFFSET 0x418

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C26_REG_OFFSET 0x41c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C26_REG_OFFSET 0x420
#define SCMI_CHANNEL_FLAGS_C26_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C26_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C26_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C26_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C26_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C26_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C26_REG_OFFSET 0x424

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C26_REG_OFFSET 0x428
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C26_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C26_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C26_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C26_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C26_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C26_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C26_REG_OFFSET 0x42c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C26_REG_OFFSET 0x430
#define SCMI_DOORBELL_C26_INTR_BIT 0
#define SCMI_DOORBELL_C26_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C26_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C26_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C26_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C26_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C26_REG_OFFSET 0x434
#define SCMI_COMPLETION_INTERRUPT_C26_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C27_REG_OFFSET 0x438

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C27_REG_OFFSET 0x43c
#define SCMI_CHANNEL_STATUS_C27_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C27_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C27_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C27_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C27_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C27_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C27_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C27_REG_OFFSET 0x440

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C27_REG_OFFSET 0x444

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C27_REG_OFFSET 0x448
#define SCMI_CHANNEL_FLAGS_C27_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C27_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C27_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C27_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C27_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C27_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C27_REG_OFFSET 0x44c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C27_REG_OFFSET 0x450
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C27_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C27_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C27_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C27_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C27_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C27_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C27_REG_OFFSET 0x454

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C27_REG_OFFSET 0x458
#define SCMI_DOORBELL_C27_INTR_BIT 0
#define SCMI_DOORBELL_C27_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C27_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C27_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C27_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C27_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C27_REG_OFFSET 0x45c
#define SCMI_COMPLETION_INTERRUPT_C27_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C28_REG_OFFSET 0x460

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C28_REG_OFFSET 0x464
#define SCMI_CHANNEL_STATUS_C28_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C28_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C28_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C28_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C28_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C28_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C28_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C28_REG_OFFSET 0x468

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C28_REG_OFFSET 0x46c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C28_REG_OFFSET 0x470
#define SCMI_CHANNEL_FLAGS_C28_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C28_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C28_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C28_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C28_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C28_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C28_REG_OFFSET 0x474

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C28_REG_OFFSET 0x478
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C28_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C28_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C28_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C28_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C28_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C28_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C28_REG_OFFSET 0x47c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C28_REG_OFFSET 0x480
#define SCMI_DOORBELL_C28_INTR_BIT 0
#define SCMI_DOORBELL_C28_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C28_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C28_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C28_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C28_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C28_REG_OFFSET 0x484
#define SCMI_COMPLETION_INTERRUPT_C28_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C29_REG_OFFSET 0x488

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C29_REG_OFFSET 0x48c
#define SCMI_CHANNEL_STATUS_C29_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C29_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C29_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C29_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C29_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C29_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C29_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C29_REG_OFFSET 0x490

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C29_REG_OFFSET 0x494

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C29_REG_OFFSET 0x498
#define SCMI_CHANNEL_FLAGS_C29_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C29_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C29_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C29_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C29_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C29_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C29_REG_OFFSET 0x49c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C29_REG_OFFSET 0x4a0
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C29_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C29_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C29_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C29_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C29_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C29_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C29_REG_OFFSET 0x4a4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C29_REG_OFFSET 0x4a8
#define SCMI_DOORBELL_C29_INTR_BIT 0
#define SCMI_DOORBELL_C29_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C29_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C29_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C29_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C29_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C29_REG_OFFSET 0x4ac
#define SCMI_COMPLETION_INTERRUPT_C29_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C30_REG_OFFSET 0x4b0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C30_REG_OFFSET 0x4b4
#define SCMI_CHANNEL_STATUS_C30_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C30_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C30_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C30_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C30_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C30_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C30_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C30_REG_OFFSET 0x4b8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C30_REG_OFFSET 0x4bc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C30_REG_OFFSET 0x4c0
#define SCMI_CHANNEL_FLAGS_C30_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C30_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C30_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C30_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C30_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C30_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C30_REG_OFFSET 0x4c4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C30_REG_OFFSET 0x4c8
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C30_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C30_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C30_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C30_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C30_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C30_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C30_REG_OFFSET 0x4cc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C30_REG_OFFSET 0x4d0
#define SCMI_DOORBELL_C30_INTR_BIT 0
#define SCMI_DOORBELL_C30_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C30_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C30_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C30_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C30_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C30_REG_OFFSET 0x4d4
#define SCMI_COMPLETION_INTERRUPT_C30_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C31_REG_OFFSET 0x4d8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C31_REG_OFFSET 0x4dc
#define SCMI_CHANNEL_STATUS_C31_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C31_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C31_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C31_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C31_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C31_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C31_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C31_REG_OFFSET 0x4e0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C31_REG_OFFSET 0x4e4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C31_REG_OFFSET 0x4e8
#define SCMI_CHANNEL_FLAGS_C31_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C31_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C31_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C31_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C31_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C31_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C31_REG_OFFSET 0x4ec

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C31_REG_OFFSET 0x4f0
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C31_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C31_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C31_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C31_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C31_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C31_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C31_REG_OFFSET 0x4f4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C31_REG_OFFSET 0x4f8
#define SCMI_DOORBELL_C31_INTR_BIT 0
#define SCMI_DOORBELL_C31_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C31_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C31_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C31_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C31_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C31_REG_OFFSET 0x4fc
#define SCMI_COMPLETION_INTERRUPT_C31_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C32_REG_OFFSET 0x500

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C32_REG_OFFSET 0x504
#define SCMI_CHANNEL_STATUS_C32_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C32_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C32_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C32_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C32_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C32_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C32_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C32_REG_OFFSET 0x508

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C32_REG_OFFSET 0x50c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C32_REG_OFFSET 0x510
#define SCMI_CHANNEL_FLAGS_C32_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C32_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C32_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C32_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C32_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C32_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C32_REG_OFFSET 0x514

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C32_REG_OFFSET 0x518
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C32_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C32_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C32_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C32_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C32_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C32_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C32_REG_OFFSET 0x51c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C32_REG_OFFSET 0x520
#define SCMI_DOORBELL_C32_INTR_BIT 0
#define SCMI_DOORBELL_C32_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C32_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C32_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C32_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C32_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C32_REG_OFFSET 0x524
#define SCMI_COMPLETION_INTERRUPT_C32_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C33_REG_OFFSET 0x528

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C33_REG_OFFSET 0x52c
#define SCMI_CHANNEL_STATUS_C33_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C33_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C33_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C33_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C33_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C33_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C33_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C33_REG_OFFSET 0x530

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C33_REG_OFFSET 0x534

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C33_REG_OFFSET 0x538
#define SCMI_CHANNEL_FLAGS_C33_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C33_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C33_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C33_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C33_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C33_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C33_REG_OFFSET 0x53c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C33_REG_OFFSET 0x540
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C33_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C33_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C33_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C33_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C33_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C33_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C33_REG_OFFSET 0x544

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C33_REG_OFFSET 0x548
#define SCMI_DOORBELL_C33_INTR_BIT 0
#define SCMI_DOORBELL_C33_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C33_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C33_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C33_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C33_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C33_REG_OFFSET 0x54c
#define SCMI_COMPLETION_INTERRUPT_C33_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C34_REG_OFFSET 0x550

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C34_REG_OFFSET 0x554
#define SCMI_CHANNEL_STATUS_C34_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C34_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C34_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C34_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C34_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C34_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C34_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C34_REG_OFFSET 0x558

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C34_REG_OFFSET 0x55c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C34_REG_OFFSET 0x560
#define SCMI_CHANNEL_FLAGS_C34_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C34_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C34_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C34_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C34_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C34_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C34_REG_OFFSET 0x564

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C34_REG_OFFSET 0x568
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C34_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C34_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C34_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C34_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C34_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C34_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C34_REG_OFFSET 0x56c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C34_REG_OFFSET 0x570
#define SCMI_DOORBELL_C34_INTR_BIT 0
#define SCMI_DOORBELL_C34_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C34_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C34_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C34_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C34_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C34_REG_OFFSET 0x574
#define SCMI_COMPLETION_INTERRUPT_C34_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C35_REG_OFFSET 0x578

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C35_REG_OFFSET 0x57c
#define SCMI_CHANNEL_STATUS_C35_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C35_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C35_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C35_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C35_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C35_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C35_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C35_REG_OFFSET 0x580

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C35_REG_OFFSET 0x584

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C35_REG_OFFSET 0x588
#define SCMI_CHANNEL_FLAGS_C35_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C35_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C35_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C35_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C35_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C35_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C35_REG_OFFSET 0x58c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C35_REG_OFFSET 0x590
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C35_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C35_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C35_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C35_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C35_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C35_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C35_REG_OFFSET 0x594

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C35_REG_OFFSET 0x598
#define SCMI_DOORBELL_C35_INTR_BIT 0
#define SCMI_DOORBELL_C35_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C35_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C35_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C35_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C35_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C35_REG_OFFSET 0x59c
#define SCMI_COMPLETION_INTERRUPT_C35_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C36_REG_OFFSET 0x5a0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C36_REG_OFFSET 0x5a4
#define SCMI_CHANNEL_STATUS_C36_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C36_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C36_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C36_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C36_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C36_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C36_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C36_REG_OFFSET 0x5a8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C36_REG_OFFSET 0x5ac

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C36_REG_OFFSET 0x5b0
#define SCMI_CHANNEL_FLAGS_C36_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C36_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C36_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C36_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C36_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C36_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C36_REG_OFFSET 0x5b4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C36_REG_OFFSET 0x5b8
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C36_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C36_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C36_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C36_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C36_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C36_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C36_REG_OFFSET 0x5bc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C36_REG_OFFSET 0x5c0
#define SCMI_DOORBELL_C36_INTR_BIT 0
#define SCMI_DOORBELL_C36_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C36_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C36_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C36_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C36_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C36_REG_OFFSET 0x5c4
#define SCMI_COMPLETION_INTERRUPT_C36_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C37_REG_OFFSET 0x5c8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C37_REG_OFFSET 0x5cc
#define SCMI_CHANNEL_STATUS_C37_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C37_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C37_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C37_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C37_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C37_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C37_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C37_REG_OFFSET 0x5d0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C37_REG_OFFSET 0x5d4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C37_REG_OFFSET 0x5d8
#define SCMI_CHANNEL_FLAGS_C37_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C37_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C37_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C37_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C37_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C37_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C37_REG_OFFSET 0x5dc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C37_REG_OFFSET 0x5e0
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C37_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C37_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C37_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C37_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C37_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C37_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C37_REG_OFFSET 0x5e4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C37_REG_OFFSET 0x5e8
#define SCMI_DOORBELL_C37_INTR_BIT 0
#define SCMI_DOORBELL_C37_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C37_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C37_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C37_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C37_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C37_REG_OFFSET 0x5ec
#define SCMI_COMPLETION_INTERRUPT_C37_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C38_REG_OFFSET 0x5f0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C38_REG_OFFSET 0x5f4
#define SCMI_CHANNEL_STATUS_C38_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C38_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C38_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C38_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C38_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C38_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C38_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C38_REG_OFFSET 0x5f8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C38_REG_OFFSET 0x5fc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C38_REG_OFFSET 0x600
#define SCMI_CHANNEL_FLAGS_C38_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C38_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C38_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C38_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C38_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C38_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C38_REG_OFFSET 0x604

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C38_REG_OFFSET 0x608
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C38_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C38_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C38_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C38_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C38_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C38_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C38_REG_OFFSET 0x60c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C38_REG_OFFSET 0x610
#define SCMI_DOORBELL_C38_INTR_BIT 0
#define SCMI_DOORBELL_C38_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C38_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C38_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C38_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C38_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C38_REG_OFFSET 0x614
#define SCMI_COMPLETION_INTERRUPT_C38_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C39_REG_OFFSET 0x618

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C39_REG_OFFSET 0x61c
#define SCMI_CHANNEL_STATUS_C39_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C39_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C39_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C39_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C39_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C39_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C39_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C39_REG_OFFSET 0x620

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C39_REG_OFFSET 0x624

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C39_REG_OFFSET 0x628
#define SCMI_CHANNEL_FLAGS_C39_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C39_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C39_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C39_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C39_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C39_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C39_REG_OFFSET 0x62c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C39_REG_OFFSET 0x630
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C39_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C39_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C39_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C39_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C39_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C39_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C39_REG_OFFSET 0x634

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C39_REG_OFFSET 0x638
#define SCMI_DOORBELL_C39_INTR_BIT 0
#define SCMI_DOORBELL_C39_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C39_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C39_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C39_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C39_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C39_REG_OFFSET 0x63c
#define SCMI_COMPLETION_INTERRUPT_C39_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C40_REG_OFFSET 0x640

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C40_REG_OFFSET 0x644
#define SCMI_CHANNEL_STATUS_C40_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C40_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C40_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C40_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C40_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C40_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C40_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C40_REG_OFFSET 0x648

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C40_REG_OFFSET 0x64c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C40_REG_OFFSET 0x650
#define SCMI_CHANNEL_FLAGS_C40_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C40_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C40_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C40_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C40_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C40_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C40_REG_OFFSET 0x654

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C40_REG_OFFSET 0x658
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C40_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C40_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C40_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C40_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C40_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C40_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C40_REG_OFFSET 0x65c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C40_REG_OFFSET 0x660
#define SCMI_DOORBELL_C40_INTR_BIT 0
#define SCMI_DOORBELL_C40_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C40_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C40_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C40_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C40_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C40_REG_OFFSET 0x664
#define SCMI_COMPLETION_INTERRUPT_C40_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C41_REG_OFFSET 0x668

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C41_REG_OFFSET 0x66c
#define SCMI_CHANNEL_STATUS_C41_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C41_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C41_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C41_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C41_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C41_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C41_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C41_REG_OFFSET 0x670

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C41_REG_OFFSET 0x674

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C41_REG_OFFSET 0x678
#define SCMI_CHANNEL_FLAGS_C41_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C41_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C41_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C41_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C41_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C41_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C41_REG_OFFSET 0x67c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C41_REG_OFFSET 0x680
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C41_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C41_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C41_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C41_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C41_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C41_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C41_REG_OFFSET 0x684

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C41_REG_OFFSET 0x688
#define SCMI_DOORBELL_C41_INTR_BIT 0
#define SCMI_DOORBELL_C41_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C41_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C41_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C41_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C41_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C41_REG_OFFSET 0x68c
#define SCMI_COMPLETION_INTERRUPT_C41_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C42_REG_OFFSET 0x690

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C42_REG_OFFSET 0x694
#define SCMI_CHANNEL_STATUS_C42_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C42_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C42_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C42_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C42_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C42_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C42_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C42_REG_OFFSET 0x698

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C42_REG_OFFSET 0x69c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C42_REG_OFFSET 0x6a0
#define SCMI_CHANNEL_FLAGS_C42_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C42_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C42_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C42_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C42_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C42_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C42_REG_OFFSET 0x6a4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C42_REG_OFFSET 0x6a8
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C42_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C42_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C42_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C42_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C42_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C42_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C42_REG_OFFSET 0x6ac

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C42_REG_OFFSET 0x6b0
#define SCMI_DOORBELL_C42_INTR_BIT 0
#define SCMI_DOORBELL_C42_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C42_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C42_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C42_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C42_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C42_REG_OFFSET 0x6b4
#define SCMI_COMPLETION_INTERRUPT_C42_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C43_REG_OFFSET 0x6b8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C43_REG_OFFSET 0x6bc
#define SCMI_CHANNEL_STATUS_C43_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C43_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C43_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C43_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C43_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C43_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C43_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C43_REG_OFFSET 0x6c0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C43_REG_OFFSET 0x6c4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C43_REG_OFFSET 0x6c8
#define SCMI_CHANNEL_FLAGS_C43_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C43_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C43_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C43_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C43_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C43_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C43_REG_OFFSET 0x6cc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C43_REG_OFFSET 0x6d0
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C43_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C43_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C43_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C43_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C43_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C43_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C43_REG_OFFSET 0x6d4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C43_REG_OFFSET 0x6d8
#define SCMI_DOORBELL_C43_INTR_BIT 0
#define SCMI_DOORBELL_C43_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C43_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C43_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C43_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C43_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C43_REG_OFFSET 0x6dc
#define SCMI_COMPLETION_INTERRUPT_C43_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C44_REG_OFFSET 0x6e0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C44_REG_OFFSET 0x6e4
#define SCMI_CHANNEL_STATUS_C44_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C44_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C44_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C44_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C44_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C44_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C44_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C44_REG_OFFSET 0x6e8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C44_REG_OFFSET 0x6ec

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C44_REG_OFFSET 0x6f0
#define SCMI_CHANNEL_FLAGS_C44_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C44_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C44_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C44_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C44_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C44_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C44_REG_OFFSET 0x6f4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C44_REG_OFFSET 0x6f8
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C44_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C44_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C44_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C44_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C44_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C44_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C44_REG_OFFSET 0x6fc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C44_REG_OFFSET 0x700
#define SCMI_DOORBELL_C44_INTR_BIT 0
#define SCMI_DOORBELL_C44_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C44_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C44_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C44_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C44_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C44_REG_OFFSET 0x704
#define SCMI_COMPLETION_INTERRUPT_C44_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C45_REG_OFFSET 0x708

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C45_REG_OFFSET 0x70c
#define SCMI_CHANNEL_STATUS_C45_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C45_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C45_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C45_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C45_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C45_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C45_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C45_REG_OFFSET 0x710

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C45_REG_OFFSET 0x714

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C45_REG_OFFSET 0x718
#define SCMI_CHANNEL_FLAGS_C45_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C45_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C45_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C45_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C45_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C45_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C45_REG_OFFSET 0x71c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C45_REG_OFFSET 0x720
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C45_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C45_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C45_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C45_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C45_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C45_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C45_REG_OFFSET 0x724

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C45_REG_OFFSET 0x728
#define SCMI_DOORBELL_C45_INTR_BIT 0
#define SCMI_DOORBELL_C45_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C45_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C45_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C45_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C45_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C45_REG_OFFSET 0x72c
#define SCMI_COMPLETION_INTERRUPT_C45_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C46_REG_OFFSET 0x730

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C46_REG_OFFSET 0x734
#define SCMI_CHANNEL_STATUS_C46_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C46_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C46_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C46_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C46_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C46_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C46_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C46_REG_OFFSET 0x738

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C46_REG_OFFSET 0x73c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C46_REG_OFFSET 0x740
#define SCMI_CHANNEL_FLAGS_C46_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C46_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C46_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C46_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C46_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C46_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C46_REG_OFFSET 0x744

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C46_REG_OFFSET 0x748
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C46_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C46_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C46_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C46_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C46_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C46_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C46_REG_OFFSET 0x74c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C46_REG_OFFSET 0x750
#define SCMI_DOORBELL_C46_INTR_BIT 0
#define SCMI_DOORBELL_C46_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C46_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C46_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C46_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C46_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C46_REG_OFFSET 0x754
#define SCMI_COMPLETION_INTERRUPT_C46_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C47_REG_OFFSET 0x758

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C47_REG_OFFSET 0x75c
#define SCMI_CHANNEL_STATUS_C47_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C47_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C47_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C47_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C47_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C47_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C47_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C47_REG_OFFSET 0x760

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C47_REG_OFFSET 0x764

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C47_REG_OFFSET 0x768
#define SCMI_CHANNEL_FLAGS_C47_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C47_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C47_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C47_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C47_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C47_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C47_REG_OFFSET 0x76c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C47_REG_OFFSET 0x770
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C47_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C47_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C47_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C47_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C47_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C47_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C47_REG_OFFSET 0x774

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C47_REG_OFFSET 0x778
#define SCMI_DOORBELL_C47_INTR_BIT 0
#define SCMI_DOORBELL_C47_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C47_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C47_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C47_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C47_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C47_REG_OFFSET 0x77c
#define SCMI_COMPLETION_INTERRUPT_C47_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C48_REG_OFFSET 0x780

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C48_REG_OFFSET 0x784
#define SCMI_CHANNEL_STATUS_C48_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C48_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C48_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C48_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C48_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C48_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C48_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C48_REG_OFFSET 0x788

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C48_REG_OFFSET 0x78c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C48_REG_OFFSET 0x790
#define SCMI_CHANNEL_FLAGS_C48_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C48_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C48_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C48_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C48_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C48_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C48_REG_OFFSET 0x794

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C48_REG_OFFSET 0x798
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C48_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C48_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C48_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C48_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C48_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C48_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C48_REG_OFFSET 0x79c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C48_REG_OFFSET 0x7a0
#define SCMI_DOORBELL_C48_INTR_BIT 0
#define SCMI_DOORBELL_C48_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C48_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C48_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C48_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C48_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C48_REG_OFFSET 0x7a4
#define SCMI_COMPLETION_INTERRUPT_C48_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C49_REG_OFFSET 0x7a8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C49_REG_OFFSET 0x7ac
#define SCMI_CHANNEL_STATUS_C49_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C49_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C49_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C49_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C49_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C49_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C49_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C49_REG_OFFSET 0x7b0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C49_REG_OFFSET 0x7b4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C49_REG_OFFSET 0x7b8
#define SCMI_CHANNEL_FLAGS_C49_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C49_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C49_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C49_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C49_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C49_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C49_REG_OFFSET 0x7bc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C49_REG_OFFSET 0x7c0
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C49_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C49_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C49_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C49_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C49_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C49_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C49_REG_OFFSET 0x7c4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C49_REG_OFFSET 0x7c8
#define SCMI_DOORBELL_C49_INTR_BIT 0
#define SCMI_DOORBELL_C49_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C49_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C49_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C49_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C49_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C49_REG_OFFSET 0x7cc
#define SCMI_COMPLETION_INTERRUPT_C49_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C50_REG_OFFSET 0x7d0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C50_REG_OFFSET 0x7d4
#define SCMI_CHANNEL_STATUS_C50_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C50_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C50_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C50_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C50_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C50_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C50_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C50_REG_OFFSET 0x7d8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C50_REG_OFFSET 0x7dc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C50_REG_OFFSET 0x7e0
#define SCMI_CHANNEL_FLAGS_C50_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C50_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C50_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C50_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C50_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C50_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C50_REG_OFFSET 0x7e4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C50_REG_OFFSET 0x7e8
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C50_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C50_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C50_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C50_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C50_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C50_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C50_REG_OFFSET 0x7ec

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C50_REG_OFFSET 0x7f0
#define SCMI_DOORBELL_C50_INTR_BIT 0
#define SCMI_DOORBELL_C50_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C50_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C50_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C50_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C50_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C50_REG_OFFSET 0x7f4
#define SCMI_COMPLETION_INTERRUPT_C50_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C51_REG_OFFSET 0x7f8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C51_REG_OFFSET 0x7fc
#define SCMI_CHANNEL_STATUS_C51_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C51_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C51_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C51_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C51_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C51_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C51_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C51_REG_OFFSET 0x800

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C51_REG_OFFSET 0x804

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C51_REG_OFFSET 0x808
#define SCMI_CHANNEL_FLAGS_C51_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C51_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C51_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C51_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C51_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C51_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C51_REG_OFFSET 0x80c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C51_REG_OFFSET 0x810
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C51_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C51_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C51_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C51_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C51_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C51_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C51_REG_OFFSET 0x814

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C51_REG_OFFSET 0x818
#define SCMI_DOORBELL_C51_INTR_BIT 0
#define SCMI_DOORBELL_C51_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C51_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C51_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C51_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C51_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C51_REG_OFFSET 0x81c
#define SCMI_COMPLETION_INTERRUPT_C51_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C52_REG_OFFSET 0x820

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C52_REG_OFFSET 0x824
#define SCMI_CHANNEL_STATUS_C52_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C52_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C52_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C52_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C52_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C52_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C52_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C52_REG_OFFSET 0x828

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C52_REG_OFFSET 0x82c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C52_REG_OFFSET 0x830
#define SCMI_CHANNEL_FLAGS_C52_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C52_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C52_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C52_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C52_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C52_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C52_REG_OFFSET 0x834

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C52_REG_OFFSET 0x838
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C52_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C52_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C52_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C52_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C52_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C52_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C52_REG_OFFSET 0x83c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C52_REG_OFFSET 0x840
#define SCMI_DOORBELL_C52_INTR_BIT 0
#define SCMI_DOORBELL_C52_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C52_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C52_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C52_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C52_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C52_REG_OFFSET 0x844
#define SCMI_COMPLETION_INTERRUPT_C52_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C53_REG_OFFSET 0x848

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C53_REG_OFFSET 0x84c
#define SCMI_CHANNEL_STATUS_C53_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C53_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C53_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C53_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C53_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C53_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C53_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C53_REG_OFFSET 0x850

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C53_REG_OFFSET 0x854

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C53_REG_OFFSET 0x858
#define SCMI_CHANNEL_FLAGS_C53_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C53_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C53_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C53_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C53_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C53_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C53_REG_OFFSET 0x85c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C53_REG_OFFSET 0x860
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C53_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C53_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C53_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C53_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C53_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C53_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C53_REG_OFFSET 0x864

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C53_REG_OFFSET 0x868
#define SCMI_DOORBELL_C53_INTR_BIT 0
#define SCMI_DOORBELL_C53_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C53_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C53_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C53_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C53_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C53_REG_OFFSET 0x86c
#define SCMI_COMPLETION_INTERRUPT_C53_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C54_REG_OFFSET 0x870

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C54_REG_OFFSET 0x874
#define SCMI_CHANNEL_STATUS_C54_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C54_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C54_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C54_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C54_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C54_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C54_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C54_REG_OFFSET 0x878

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C54_REG_OFFSET 0x87c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C54_REG_OFFSET 0x880
#define SCMI_CHANNEL_FLAGS_C54_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C54_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C54_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C54_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C54_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C54_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C54_REG_OFFSET 0x884

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C54_REG_OFFSET 0x888
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C54_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C54_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C54_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C54_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C54_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C54_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C54_REG_OFFSET 0x88c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C54_REG_OFFSET 0x890
#define SCMI_DOORBELL_C54_INTR_BIT 0
#define SCMI_DOORBELL_C54_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C54_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C54_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C54_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C54_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C54_REG_OFFSET 0x894
#define SCMI_COMPLETION_INTERRUPT_C54_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C55_REG_OFFSET 0x898

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C55_REG_OFFSET 0x89c
#define SCMI_CHANNEL_STATUS_C55_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C55_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C55_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C55_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C55_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C55_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C55_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C55_REG_OFFSET 0x8a0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C55_REG_OFFSET 0x8a4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C55_REG_OFFSET 0x8a8
#define SCMI_CHANNEL_FLAGS_C55_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C55_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C55_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C55_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C55_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C55_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C55_REG_OFFSET 0x8ac

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C55_REG_OFFSET 0x8b0
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C55_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C55_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C55_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C55_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C55_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C55_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C55_REG_OFFSET 0x8b4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C55_REG_OFFSET 0x8b8
#define SCMI_DOORBELL_C55_INTR_BIT 0
#define SCMI_DOORBELL_C55_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C55_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C55_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C55_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C55_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C55_REG_OFFSET 0x8bc
#define SCMI_COMPLETION_INTERRUPT_C55_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C56_REG_OFFSET 0x8c0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C56_REG_OFFSET 0x8c4
#define SCMI_CHANNEL_STATUS_C56_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C56_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C56_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C56_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C56_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C56_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C56_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C56_REG_OFFSET 0x8c8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C56_REG_OFFSET 0x8cc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C56_REG_OFFSET 0x8d0
#define SCMI_CHANNEL_FLAGS_C56_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C56_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C56_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C56_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C56_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C56_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C56_REG_OFFSET 0x8d4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C56_REG_OFFSET 0x8d8
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C56_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C56_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C56_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C56_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C56_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C56_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C56_REG_OFFSET 0x8dc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C56_REG_OFFSET 0x8e0
#define SCMI_DOORBELL_C56_INTR_BIT 0
#define SCMI_DOORBELL_C56_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C56_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C56_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C56_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C56_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C56_REG_OFFSET 0x8e4
#define SCMI_COMPLETION_INTERRUPT_C56_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C57_REG_OFFSET 0x8e8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C57_REG_OFFSET 0x8ec
#define SCMI_CHANNEL_STATUS_C57_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C57_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C57_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C57_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C57_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C57_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C57_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C57_REG_OFFSET 0x8f0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C57_REG_OFFSET 0x8f4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C57_REG_OFFSET 0x8f8
#define SCMI_CHANNEL_FLAGS_C57_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C57_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C57_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C57_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C57_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C57_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C57_REG_OFFSET 0x8fc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C57_REG_OFFSET 0x900
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C57_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C57_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C57_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C57_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C57_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C57_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C57_REG_OFFSET 0x904

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C57_REG_OFFSET 0x908
#define SCMI_DOORBELL_C57_INTR_BIT 0
#define SCMI_DOORBELL_C57_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C57_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C57_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C57_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C57_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C57_REG_OFFSET 0x90c
#define SCMI_COMPLETION_INTERRUPT_C57_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C58_REG_OFFSET 0x910

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C58_REG_OFFSET 0x914
#define SCMI_CHANNEL_STATUS_C58_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C58_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C58_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C58_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C58_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C58_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C58_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C58_REG_OFFSET 0x918

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C58_REG_OFFSET 0x91c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C58_REG_OFFSET 0x920
#define SCMI_CHANNEL_FLAGS_C58_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C58_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C58_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C58_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C58_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C58_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C58_REG_OFFSET 0x924

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C58_REG_OFFSET 0x928
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C58_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C58_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C58_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C58_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C58_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C58_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C58_REG_OFFSET 0x92c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C58_REG_OFFSET 0x930
#define SCMI_DOORBELL_C58_INTR_BIT 0
#define SCMI_DOORBELL_C58_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C58_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C58_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C58_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C58_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C58_REG_OFFSET 0x934
#define SCMI_COMPLETION_INTERRUPT_C58_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C59_REG_OFFSET 0x938

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C59_REG_OFFSET 0x93c
#define SCMI_CHANNEL_STATUS_C59_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C59_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C59_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C59_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C59_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C59_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C59_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C59_REG_OFFSET 0x940

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C59_REG_OFFSET 0x944

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C59_REG_OFFSET 0x948
#define SCMI_CHANNEL_FLAGS_C59_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C59_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C59_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C59_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C59_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C59_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C59_REG_OFFSET 0x94c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C59_REG_OFFSET 0x950
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C59_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C59_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C59_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C59_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C59_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C59_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C59_REG_OFFSET 0x954

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C59_REG_OFFSET 0x958
#define SCMI_DOORBELL_C59_INTR_BIT 0
#define SCMI_DOORBELL_C59_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C59_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C59_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C59_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C59_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C59_REG_OFFSET 0x95c
#define SCMI_COMPLETION_INTERRUPT_C59_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C60_REG_OFFSET 0x960

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C60_REG_OFFSET 0x964
#define SCMI_CHANNEL_STATUS_C60_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C60_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C60_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C60_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C60_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C60_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C60_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C60_REG_OFFSET 0x968

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C60_REG_OFFSET 0x96c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C60_REG_OFFSET 0x970
#define SCMI_CHANNEL_FLAGS_C60_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C60_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C60_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C60_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C60_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C60_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C60_REG_OFFSET 0x974

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C60_REG_OFFSET 0x978
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C60_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C60_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C60_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C60_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C60_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C60_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C60_REG_OFFSET 0x97c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C60_REG_OFFSET 0x980
#define SCMI_DOORBELL_C60_INTR_BIT 0
#define SCMI_DOORBELL_C60_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C60_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C60_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C60_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C60_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C60_REG_OFFSET 0x984
#define SCMI_COMPLETION_INTERRUPT_C60_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C61_REG_OFFSET 0x988

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C61_REG_OFFSET 0x98c
#define SCMI_CHANNEL_STATUS_C61_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C61_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C61_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C61_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C61_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C61_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C61_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C61_REG_OFFSET 0x990

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C61_REG_OFFSET 0x994

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C61_REG_OFFSET 0x998
#define SCMI_CHANNEL_FLAGS_C61_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C61_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C61_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C61_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C61_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C61_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C61_REG_OFFSET 0x99c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C61_REG_OFFSET 0x9a0
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C61_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C61_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C61_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C61_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C61_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C61_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C61_REG_OFFSET 0x9a4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C61_REG_OFFSET 0x9a8
#define SCMI_DOORBELL_C61_INTR_BIT 0
#define SCMI_DOORBELL_C61_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C61_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C61_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C61_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C61_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C61_REG_OFFSET 0x9ac
#define SCMI_COMPLETION_INTERRUPT_C61_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C62_REG_OFFSET 0x9b0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C62_REG_OFFSET 0x9b4
#define SCMI_CHANNEL_STATUS_C62_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C62_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C62_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C62_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C62_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C62_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C62_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C62_REG_OFFSET 0x9b8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C62_REG_OFFSET 0x9bc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C62_REG_OFFSET 0x9c0
#define SCMI_CHANNEL_FLAGS_C62_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C62_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C62_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C62_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C62_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C62_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C62_REG_OFFSET 0x9c4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C62_REG_OFFSET 0x9c8
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C62_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C62_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C62_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C62_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C62_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C62_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C62_REG_OFFSET 0x9cc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C62_REG_OFFSET 0x9d0
#define SCMI_DOORBELL_C62_INTR_BIT 0
#define SCMI_DOORBELL_C62_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C62_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C62_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C62_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C62_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C62_REG_OFFSET 0x9d4
#define SCMI_COMPLETION_INTERRUPT_C62_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C63_REG_OFFSET 0x9d8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C63_REG_OFFSET 0x9dc
#define SCMI_CHANNEL_STATUS_C63_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C63_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C63_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C63_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C63_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C63_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C63_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C63_REG_OFFSET 0x9e0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C63_REG_OFFSET 0x9e4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C63_REG_OFFSET 0x9e8
#define SCMI_CHANNEL_FLAGS_C63_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C63_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C63_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C63_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C63_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C63_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C63_REG_OFFSET 0x9ec

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C63_REG_OFFSET 0x9f0
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C63_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C63_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C63_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C63_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C63_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C63_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C63_REG_OFFSET 0x9f4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C63_REG_OFFSET 0x9f8
#define SCMI_DOORBELL_C63_INTR_BIT 0
#define SCMI_DOORBELL_C63_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C63_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C63_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C63_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C63_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C63_REG_OFFSET 0x9fc
#define SCMI_COMPLETION_INTERRUPT_C63_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C64_REG_OFFSET 0xa00

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C64_REG_OFFSET 0xa04
#define SCMI_CHANNEL_STATUS_C64_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C64_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C64_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C64_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C64_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C64_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C64_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C64_REG_OFFSET 0xa08

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C64_REG_OFFSET 0xa0c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C64_REG_OFFSET 0xa10
#define SCMI_CHANNEL_FLAGS_C64_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C64_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C64_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C64_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C64_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C64_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C64_REG_OFFSET 0xa14

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C64_REG_OFFSET 0xa18
#define SCMI_MESSAGE_HEADER_C64_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C64_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C64_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C64_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C64_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C64_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C64_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C64_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C64_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C64_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C64_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C64_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C64_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C64_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C64_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C64_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C64_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C64_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C64_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C64_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C64_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C64_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C64_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C64_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C64_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C64_REG_OFFSET 0xa1c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C64_REG_OFFSET 0xa20
#define SCMI_DOORBELL_C64_INTR_BIT 0
#define SCMI_DOORBELL_C64_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C64_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C64_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C64_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C64_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C64_REG_OFFSET 0xa24
#define SCMI_COMPLETION_INTERRUPT_C64_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C64_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C64_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C64_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C64_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C64_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C65_REG_OFFSET 0xa28

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C65_REG_OFFSET 0xa2c
#define SCMI_CHANNEL_STATUS_C65_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C65_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C65_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C65_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C65_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C65_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C65_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C65_REG_OFFSET 0xa30

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C65_REG_OFFSET 0xa34

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C65_REG_OFFSET 0xa38
#define SCMI_CHANNEL_FLAGS_C65_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C65_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C65_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C65_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C65_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C65_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C65_REG_OFFSET 0xa3c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C65_REG_OFFSET 0xa40
#define SCMI_MESSAGE_HEADER_C65_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C65_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C65_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C65_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C65_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C65_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C65_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C65_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C65_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C65_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C65_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C65_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C65_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C65_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C65_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C65_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C65_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C65_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C65_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C65_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C65_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C65_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C65_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C65_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C65_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C65_REG_OFFSET 0xa44

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C65_REG_OFFSET 0xa48
#define SCMI_DOORBELL_C65_INTR_BIT 0
#define SCMI_DOORBELL_C65_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C65_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C65_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C65_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C65_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C65_REG_OFFSET 0xa4c
#define SCMI_COMPLETION_INTERRUPT_C65_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C65_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C65_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C65_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C65_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C65_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C66_REG_OFFSET 0xa50

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C66_REG_OFFSET 0xa54
#define SCMI_CHANNEL_STATUS_C66_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C66_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C66_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C66_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C66_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C66_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C66_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C66_REG_OFFSET 0xa58

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C66_REG_OFFSET 0xa5c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C66_REG_OFFSET 0xa60
#define SCMI_CHANNEL_FLAGS_C66_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C66_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C66_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C66_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C66_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C66_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C66_REG_OFFSET 0xa64

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C66_REG_OFFSET 0xa68
#define SCMI_MESSAGE_HEADER_C66_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C66_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C66_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C66_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C66_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C66_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C66_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C66_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C66_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C66_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C66_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C66_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C66_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C66_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C66_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C66_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C66_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C66_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C66_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C66_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C66_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C66_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C66_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C66_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C66_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C66_REG_OFFSET 0xa6c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C66_REG_OFFSET 0xa70
#define SCMI_DOORBELL_C66_INTR_BIT 0
#define SCMI_DOORBELL_C66_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C66_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C66_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C66_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C66_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C66_REG_OFFSET 0xa74
#define SCMI_COMPLETION_INTERRUPT_C66_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C66_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C66_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C66_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C66_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C66_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C67_REG_OFFSET 0xa78

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C67_REG_OFFSET 0xa7c
#define SCMI_CHANNEL_STATUS_C67_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C67_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C67_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C67_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C67_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C67_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C67_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C67_REG_OFFSET 0xa80

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C67_REG_OFFSET 0xa84

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C67_REG_OFFSET 0xa88
#define SCMI_CHANNEL_FLAGS_C67_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C67_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C67_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C67_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C67_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C67_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C67_REG_OFFSET 0xa8c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C67_REG_OFFSET 0xa90
#define SCMI_MESSAGE_HEADER_C67_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C67_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C67_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C67_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C67_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C67_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C67_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C67_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C67_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C67_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C67_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C67_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C67_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C67_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C67_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C67_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C67_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C67_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C67_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C67_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C67_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C67_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C67_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C67_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C67_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C67_REG_OFFSET 0xa94

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C67_REG_OFFSET 0xa98
#define SCMI_DOORBELL_C67_INTR_BIT 0
#define SCMI_DOORBELL_C67_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C67_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C67_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C67_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C67_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C67_REG_OFFSET 0xa9c
#define SCMI_COMPLETION_INTERRUPT_C67_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C67_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C67_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C67_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C67_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C67_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C68_REG_OFFSET 0xaa0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C68_REG_OFFSET 0xaa4
#define SCMI_CHANNEL_STATUS_C68_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C68_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C68_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C68_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C68_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C68_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C68_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C68_REG_OFFSET 0xaa8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C68_REG_OFFSET 0xaac

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C68_REG_OFFSET 0xab0
#define SCMI_CHANNEL_FLAGS_C68_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C68_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C68_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C68_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C68_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C68_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C68_REG_OFFSET 0xab4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C68_REG_OFFSET 0xab8
#define SCMI_MESSAGE_HEADER_C68_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C68_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C68_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C68_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C68_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C68_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C68_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C68_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C68_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C68_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C68_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C68_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C68_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C68_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C68_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C68_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C68_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C68_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C68_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C68_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C68_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C68_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C68_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C68_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C68_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C68_REG_OFFSET 0xabc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C68_REG_OFFSET 0xac0
#define SCMI_DOORBELL_C68_INTR_BIT 0
#define SCMI_DOORBELL_C68_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C68_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C68_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C68_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C68_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C68_REG_OFFSET 0xac4
#define SCMI_COMPLETION_INTERRUPT_C68_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C68_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C68_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C68_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C68_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C68_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C69_REG_OFFSET 0xac8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C69_REG_OFFSET 0xacc
#define SCMI_CHANNEL_STATUS_C69_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C69_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C69_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C69_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C69_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C69_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C69_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C69_REG_OFFSET 0xad0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C69_REG_OFFSET 0xad4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C69_REG_OFFSET 0xad8
#define SCMI_CHANNEL_FLAGS_C69_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C69_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C69_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C69_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C69_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C69_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C69_REG_OFFSET 0xadc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C69_REG_OFFSET 0xae0
#define SCMI_MESSAGE_HEADER_C69_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C69_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C69_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C69_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C69_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C69_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C69_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C69_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C69_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C69_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C69_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C69_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C69_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C69_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C69_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C69_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C69_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C69_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C69_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C69_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C69_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C69_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C69_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C69_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C69_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C69_REG_OFFSET 0xae4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C69_REG_OFFSET 0xae8
#define SCMI_DOORBELL_C69_INTR_BIT 0
#define SCMI_DOORBELL_C69_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C69_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C69_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C69_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C69_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C69_REG_OFFSET 0xaec
#define SCMI_COMPLETION_INTERRUPT_C69_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C69_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C69_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C69_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C69_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C69_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C70_REG_OFFSET 0xaf0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C70_REG_OFFSET 0xaf4
#define SCMI_CHANNEL_STATUS_C70_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C70_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C70_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C70_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C70_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C70_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C70_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C70_REG_OFFSET 0xaf8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C70_REG_OFFSET 0xafc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C70_REG_OFFSET 0xb00
#define SCMI_CHANNEL_FLAGS_C70_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C70_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C70_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C70_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C70_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C70_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C70_REG_OFFSET 0xb04

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C70_REG_OFFSET 0xb08
#define SCMI_MESSAGE_HEADER_C70_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C70_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C70_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C70_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C70_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C70_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C70_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C70_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C70_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C70_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C70_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C70_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C70_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C70_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C70_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C70_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C70_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C70_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C70_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C70_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C70_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C70_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C70_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C70_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C70_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C70_REG_OFFSET 0xb0c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C70_REG_OFFSET 0xb10
#define SCMI_DOORBELL_C70_INTR_BIT 0
#define SCMI_DOORBELL_C70_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C70_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C70_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C70_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C70_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C70_REG_OFFSET 0xb14
#define SCMI_COMPLETION_INTERRUPT_C70_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C70_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C70_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C70_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C70_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C70_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C71_REG_OFFSET 0xb18

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C71_REG_OFFSET 0xb1c
#define SCMI_CHANNEL_STATUS_C71_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C71_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C71_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C71_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C71_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C71_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C71_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C71_REG_OFFSET 0xb20

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C71_REG_OFFSET 0xb24

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C71_REG_OFFSET 0xb28
#define SCMI_CHANNEL_FLAGS_C71_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C71_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C71_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C71_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C71_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C71_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C71_REG_OFFSET 0xb2c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C71_REG_OFFSET 0xb30
#define SCMI_MESSAGE_HEADER_C71_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C71_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C71_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C71_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C71_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C71_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C71_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C71_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C71_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C71_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C71_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C71_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C71_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C71_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C71_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C71_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C71_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C71_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C71_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C71_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C71_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C71_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C71_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C71_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C71_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C71_REG_OFFSET 0xb34

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C71_REG_OFFSET 0xb38
#define SCMI_DOORBELL_C71_INTR_BIT 0
#define SCMI_DOORBELL_C71_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C71_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C71_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C71_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C71_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C71_REG_OFFSET 0xb3c
#define SCMI_COMPLETION_INTERRUPT_C71_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C71_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C71_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C71_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C71_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C71_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C72_REG_OFFSET 0xb40

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C72_REG_OFFSET 0xb44
#define SCMI_CHANNEL_STATUS_C72_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C72_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C72_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C72_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C72_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C72_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C72_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C72_REG_OFFSET 0xb48

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C72_REG_OFFSET 0xb4c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C72_REG_OFFSET 0xb50
#define SCMI_CHANNEL_FLAGS_C72_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C72_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C72_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C72_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C72_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C72_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C72_REG_OFFSET 0xb54

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C72_REG_OFFSET 0xb58
#define SCMI_MESSAGE_HEADER_C72_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C72_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C72_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C72_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C72_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C72_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C72_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C72_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C72_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C72_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C72_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C72_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C72_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C72_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C72_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C72_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C72_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C72_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C72_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C72_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C72_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C72_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C72_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C72_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C72_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C72_REG_OFFSET 0xb5c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C72_REG_OFFSET 0xb60
#define SCMI_DOORBELL_C72_INTR_BIT 0
#define SCMI_DOORBELL_C72_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C72_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C72_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C72_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C72_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C72_REG_OFFSET 0xb64
#define SCMI_COMPLETION_INTERRUPT_C72_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C72_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C72_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C72_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C72_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C72_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C73_REG_OFFSET 0xb68

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C73_REG_OFFSET 0xb6c
#define SCMI_CHANNEL_STATUS_C73_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C73_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C73_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C73_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C73_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C73_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C73_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C73_REG_OFFSET 0xb70

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C73_REG_OFFSET 0xb74

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C73_REG_OFFSET 0xb78
#define SCMI_CHANNEL_FLAGS_C73_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C73_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C73_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C73_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C73_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C73_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C73_REG_OFFSET 0xb7c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C73_REG_OFFSET 0xb80
#define SCMI_MESSAGE_HEADER_C73_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C73_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C73_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C73_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C73_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C73_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C73_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C73_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C73_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C73_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C73_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C73_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C73_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C73_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C73_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C73_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C73_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C73_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C73_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C73_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C73_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C73_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C73_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C73_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C73_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C73_REG_OFFSET 0xb84

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C73_REG_OFFSET 0xb88
#define SCMI_DOORBELL_C73_INTR_BIT 0
#define SCMI_DOORBELL_C73_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C73_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C73_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C73_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C73_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C73_REG_OFFSET 0xb8c
#define SCMI_COMPLETION_INTERRUPT_C73_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C73_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C73_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C73_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C73_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C73_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C74_REG_OFFSET 0xb90

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C74_REG_OFFSET 0xb94
#define SCMI_CHANNEL_STATUS_C74_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C74_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C74_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C74_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C74_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C74_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C74_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C74_REG_OFFSET 0xb98

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C74_REG_OFFSET 0xb9c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C74_REG_OFFSET 0xba0
#define SCMI_CHANNEL_FLAGS_C74_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C74_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C74_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C74_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C74_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C74_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C74_REG_OFFSET 0xba4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C74_REG_OFFSET 0xba8
#define SCMI_MESSAGE_HEADER_C74_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C74_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C74_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C74_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C74_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C74_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C74_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C74_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C74_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C74_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C74_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C74_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C74_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C74_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C74_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C74_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C74_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C74_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C74_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C74_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C74_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C74_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C74_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C74_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C74_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C74_REG_OFFSET 0xbac

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C74_REG_OFFSET 0xbb0
#define SCMI_DOORBELL_C74_INTR_BIT 0
#define SCMI_DOORBELL_C74_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C74_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C74_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C74_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C74_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C74_REG_OFFSET 0xbb4
#define SCMI_COMPLETION_INTERRUPT_C74_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C74_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C74_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C74_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C74_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C74_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C75_REG_OFFSET 0xbb8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C75_REG_OFFSET 0xbbc
#define SCMI_CHANNEL_STATUS_C75_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C75_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C75_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C75_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C75_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C75_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C75_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C75_REG_OFFSET 0xbc0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C75_REG_OFFSET 0xbc4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C75_REG_OFFSET 0xbc8
#define SCMI_CHANNEL_FLAGS_C75_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C75_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C75_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C75_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C75_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C75_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C75_REG_OFFSET 0xbcc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C75_REG_OFFSET 0xbd0
#define SCMI_MESSAGE_HEADER_C75_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C75_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C75_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C75_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C75_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C75_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C75_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C75_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C75_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C75_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C75_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C75_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C75_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C75_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C75_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C75_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C75_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C75_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C75_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C75_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C75_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C75_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C75_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C75_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C75_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C75_REG_OFFSET 0xbd4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C75_REG_OFFSET 0xbd8
#define SCMI_DOORBELL_C75_INTR_BIT 0
#define SCMI_DOORBELL_C75_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C75_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C75_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C75_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C75_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C75_REG_OFFSET 0xbdc
#define SCMI_COMPLETION_INTERRUPT_C75_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C75_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C75_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C75_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C75_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C75_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C76_REG_OFFSET 0xbe0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C76_REG_OFFSET 0xbe4
#define SCMI_CHANNEL_STATUS_C76_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C76_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C76_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C76_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C76_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C76_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C76_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C76_REG_OFFSET 0xbe8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C76_REG_OFFSET 0xbec

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C76_REG_OFFSET 0xbf0
#define SCMI_CHANNEL_FLAGS_C76_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C76_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C76_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C76_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C76_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C76_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C76_REG_OFFSET 0xbf4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C76_REG_OFFSET 0xbf8
#define SCMI_MESSAGE_HEADER_C76_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C76_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C76_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C76_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C76_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C76_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C76_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C76_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C76_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C76_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C76_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C76_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C76_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C76_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C76_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C76_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C76_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C76_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C76_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C76_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C76_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C76_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C76_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C76_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C76_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C76_REG_OFFSET 0xbfc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C76_REG_OFFSET 0xc00
#define SCMI_DOORBELL_C76_INTR_BIT 0
#define SCMI_DOORBELL_C76_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C76_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C76_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C76_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C76_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C76_REG_OFFSET 0xc04
#define SCMI_COMPLETION_INTERRUPT_C76_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C76_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C76_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C76_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C76_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C76_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C77_REG_OFFSET 0xc08

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C77_REG_OFFSET 0xc0c
#define SCMI_CHANNEL_STATUS_C77_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C77_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C77_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C77_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C77_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C77_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C77_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C77_REG_OFFSET 0xc10

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C77_REG_OFFSET 0xc14

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C77_REG_OFFSET 0xc18
#define SCMI_CHANNEL_FLAGS_C77_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C77_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C77_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C77_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C77_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C77_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C77_REG_OFFSET 0xc1c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C77_REG_OFFSET 0xc20
#define SCMI_MESSAGE_HEADER_C77_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C77_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C77_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C77_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C77_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C77_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C77_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C77_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C77_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C77_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C77_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C77_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C77_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C77_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C77_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C77_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C77_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C77_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C77_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C77_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C77_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C77_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C77_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C77_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C77_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C77_REG_OFFSET 0xc24

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C77_REG_OFFSET 0xc28
#define SCMI_DOORBELL_C77_INTR_BIT 0
#define SCMI_DOORBELL_C77_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C77_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C77_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C77_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C77_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C77_REG_OFFSET 0xc2c
#define SCMI_COMPLETION_INTERRUPT_C77_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C77_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C77_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C77_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C77_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C77_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C78_REG_OFFSET 0xc30

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C78_REG_OFFSET 0xc34
#define SCMI_CHANNEL_STATUS_C78_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C78_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C78_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C78_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C78_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C78_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C78_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C78_REG_OFFSET 0xc38

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C78_REG_OFFSET 0xc3c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C78_REG_OFFSET 0xc40
#define SCMI_CHANNEL_FLAGS_C78_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C78_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C78_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C78_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C78_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C78_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C78_REG_OFFSET 0xc44

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C78_REG_OFFSET 0xc48
#define SCMI_MESSAGE_HEADER_C78_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C78_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C78_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C78_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C78_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C78_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C78_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C78_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C78_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C78_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C78_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C78_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C78_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C78_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C78_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C78_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C78_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C78_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C78_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C78_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C78_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C78_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C78_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C78_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C78_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C78_REG_OFFSET 0xc4c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C78_REG_OFFSET 0xc50
#define SCMI_DOORBELL_C78_INTR_BIT 0
#define SCMI_DOORBELL_C78_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C78_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C78_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C78_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C78_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C78_REG_OFFSET 0xc54
#define SCMI_COMPLETION_INTERRUPT_C78_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C78_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C78_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C78_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C78_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C78_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C79_REG_OFFSET 0xc58

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C79_REG_OFFSET 0xc5c
#define SCMI_CHANNEL_STATUS_C79_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C79_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C79_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C79_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C79_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C79_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C79_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C79_REG_OFFSET 0xc60

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C79_REG_OFFSET 0xc64

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C79_REG_OFFSET 0xc68
#define SCMI_CHANNEL_FLAGS_C79_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C79_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C79_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C79_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C79_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C79_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C79_REG_OFFSET 0xc6c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C79_REG_OFFSET 0xc70
#define SCMI_MESSAGE_HEADER_C79_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C79_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C79_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C79_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C79_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C79_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C79_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C79_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C79_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C79_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C79_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C79_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C79_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C79_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C79_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C79_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C79_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C79_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C79_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C79_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C79_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C79_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C79_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C79_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C79_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C79_REG_OFFSET 0xc74

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C79_REG_OFFSET 0xc78
#define SCMI_DOORBELL_C79_INTR_BIT 0
#define SCMI_DOORBELL_C79_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C79_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C79_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C79_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C79_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C79_REG_OFFSET 0xc7c
#define SCMI_COMPLETION_INTERRUPT_C79_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C79_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C79_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C79_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C79_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C79_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C80_REG_OFFSET 0xc80

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C80_REG_OFFSET 0xc84
#define SCMI_CHANNEL_STATUS_C80_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C80_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C80_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C80_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C80_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C80_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C80_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C80_REG_OFFSET 0xc88

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C80_REG_OFFSET 0xc8c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C80_REG_OFFSET 0xc90
#define SCMI_CHANNEL_FLAGS_C80_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C80_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C80_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C80_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C80_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C80_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C80_REG_OFFSET 0xc94

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C80_REG_OFFSET 0xc98
#define SCMI_MESSAGE_HEADER_C80_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C80_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C80_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C80_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C80_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C80_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C80_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C80_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C80_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C80_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C80_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C80_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C80_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C80_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C80_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C80_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C80_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C80_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C80_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C80_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C80_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C80_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C80_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C80_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C80_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C80_REG_OFFSET 0xc9c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C80_REG_OFFSET 0xca0
#define SCMI_DOORBELL_C80_INTR_BIT 0
#define SCMI_DOORBELL_C80_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C80_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C80_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C80_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C80_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C80_REG_OFFSET 0xca4
#define SCMI_COMPLETION_INTERRUPT_C80_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C80_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C80_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C80_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C80_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C80_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C81_REG_OFFSET 0xca8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C81_REG_OFFSET 0xcac
#define SCMI_CHANNEL_STATUS_C81_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C81_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C81_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C81_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C81_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C81_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C81_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C81_REG_OFFSET 0xcb0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C81_REG_OFFSET 0xcb4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C81_REG_OFFSET 0xcb8
#define SCMI_CHANNEL_FLAGS_C81_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C81_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C81_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C81_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C81_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C81_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C81_REG_OFFSET 0xcbc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C81_REG_OFFSET 0xcc0
#define SCMI_MESSAGE_HEADER_C81_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C81_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C81_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C81_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C81_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C81_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C81_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C81_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C81_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C81_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C81_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C81_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C81_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C81_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C81_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C81_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C81_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C81_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C81_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C81_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C81_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C81_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C81_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C81_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C81_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C81_REG_OFFSET 0xcc4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C81_REG_OFFSET 0xcc8
#define SCMI_DOORBELL_C81_INTR_BIT 0
#define SCMI_DOORBELL_C81_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C81_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C81_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C81_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C81_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C81_REG_OFFSET 0xccc
#define SCMI_COMPLETION_INTERRUPT_C81_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C81_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C81_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C81_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C81_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C81_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C82_REG_OFFSET 0xcd0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C82_REG_OFFSET 0xcd4
#define SCMI_CHANNEL_STATUS_C82_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C82_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C82_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C82_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C82_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C82_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C82_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C82_REG_OFFSET 0xcd8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C82_REG_OFFSET 0xcdc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C82_REG_OFFSET 0xce0
#define SCMI_CHANNEL_FLAGS_C82_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C82_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C82_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C82_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C82_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C82_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C82_REG_OFFSET 0xce4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C82_REG_OFFSET 0xce8
#define SCMI_MESSAGE_HEADER_C82_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C82_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C82_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C82_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C82_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C82_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C82_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C82_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C82_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C82_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C82_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C82_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C82_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C82_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C82_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C82_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C82_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C82_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C82_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C82_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C82_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C82_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C82_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C82_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C82_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C82_REG_OFFSET 0xcec

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C82_REG_OFFSET 0xcf0
#define SCMI_DOORBELL_C82_INTR_BIT 0
#define SCMI_DOORBELL_C82_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C82_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C82_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C82_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C82_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C82_REG_OFFSET 0xcf4
#define SCMI_COMPLETION_INTERRUPT_C82_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C82_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C82_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C82_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C82_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C82_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C83_REG_OFFSET 0xcf8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C83_REG_OFFSET 0xcfc
#define SCMI_CHANNEL_STATUS_C83_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C83_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C83_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C83_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C83_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C83_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C83_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C83_REG_OFFSET 0xd00

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C83_REG_OFFSET 0xd04

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C83_REG_OFFSET 0xd08
#define SCMI_CHANNEL_FLAGS_C83_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C83_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C83_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C83_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C83_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C83_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C83_REG_OFFSET 0xd0c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C83_REG_OFFSET 0xd10
#define SCMI_MESSAGE_HEADER_C83_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C83_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C83_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C83_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C83_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C83_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C83_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C83_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C83_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C83_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C83_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C83_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C83_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C83_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C83_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C83_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C83_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C83_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C83_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C83_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C83_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C83_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C83_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C83_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C83_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C83_REG_OFFSET 0xd14

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C83_REG_OFFSET 0xd18
#define SCMI_DOORBELL_C83_INTR_BIT 0
#define SCMI_DOORBELL_C83_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C83_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C83_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C83_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C83_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C83_REG_OFFSET 0xd1c
#define SCMI_COMPLETION_INTERRUPT_C83_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C83_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C83_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C83_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C83_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C83_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C84_REG_OFFSET 0xd20

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C84_REG_OFFSET 0xd24
#define SCMI_CHANNEL_STATUS_C84_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C84_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C84_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C84_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C84_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C84_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C84_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C84_REG_OFFSET 0xd28

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C84_REG_OFFSET 0xd2c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C84_REG_OFFSET 0xd30
#define SCMI_CHANNEL_FLAGS_C84_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C84_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C84_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C84_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C84_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C84_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C84_REG_OFFSET 0xd34

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C84_REG_OFFSET 0xd38
#define SCMI_MESSAGE_HEADER_C84_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C84_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C84_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C84_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C84_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C84_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C84_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C84_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C84_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C84_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C84_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C84_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C84_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C84_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C84_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C84_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C84_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C84_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C84_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C84_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C84_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C84_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C84_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C84_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C84_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C84_REG_OFFSET 0xd3c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C84_REG_OFFSET 0xd40
#define SCMI_DOORBELL_C84_INTR_BIT 0
#define SCMI_DOORBELL_C84_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C84_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C84_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C84_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C84_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C84_REG_OFFSET 0xd44
#define SCMI_COMPLETION_INTERRUPT_C84_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C84_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C84_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C84_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C84_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C84_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C85_REG_OFFSET 0xd48

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C85_REG_OFFSET 0xd4c
#define SCMI_CHANNEL_STATUS_C85_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C85_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C85_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C85_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C85_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C85_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C85_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C85_REG_OFFSET 0xd50

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C85_REG_OFFSET 0xd54

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C85_REG_OFFSET 0xd58
#define SCMI_CHANNEL_FLAGS_C85_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C85_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C85_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C85_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C85_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C85_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C85_REG_OFFSET 0xd5c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C85_REG_OFFSET 0xd60
#define SCMI_MESSAGE_HEADER_C85_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C85_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C85_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C85_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C85_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C85_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C85_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C85_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C85_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C85_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C85_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C85_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C85_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C85_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C85_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C85_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C85_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C85_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C85_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C85_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C85_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C85_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C85_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C85_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C85_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C85_REG_OFFSET 0xd64

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C85_REG_OFFSET 0xd68
#define SCMI_DOORBELL_C85_INTR_BIT 0
#define SCMI_DOORBELL_C85_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C85_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C85_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C85_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C85_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C85_REG_OFFSET 0xd6c
#define SCMI_COMPLETION_INTERRUPT_C85_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C85_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C85_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C85_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C85_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C85_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C86_REG_OFFSET 0xd70

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C86_REG_OFFSET 0xd74
#define SCMI_CHANNEL_STATUS_C86_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C86_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C86_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C86_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C86_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C86_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C86_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C86_REG_OFFSET 0xd78

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C86_REG_OFFSET 0xd7c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C86_REG_OFFSET 0xd80
#define SCMI_CHANNEL_FLAGS_C86_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C86_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C86_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C86_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C86_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C86_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C86_REG_OFFSET 0xd84

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C86_REG_OFFSET 0xd88
#define SCMI_MESSAGE_HEADER_C86_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C86_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C86_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C86_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C86_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C86_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C86_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C86_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C86_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C86_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C86_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C86_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C86_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C86_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C86_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C86_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C86_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C86_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C86_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C86_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C86_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C86_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C86_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C86_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C86_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C86_REG_OFFSET 0xd8c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C86_REG_OFFSET 0xd90
#define SCMI_DOORBELL_C86_INTR_BIT 0
#define SCMI_DOORBELL_C86_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C86_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C86_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C86_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C86_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C86_REG_OFFSET 0xd94
#define SCMI_COMPLETION_INTERRUPT_C86_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C86_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C86_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C86_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C86_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C86_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C87_REG_OFFSET 0xd98

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C87_REG_OFFSET 0xd9c
#define SCMI_CHANNEL_STATUS_C87_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C87_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C87_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C87_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C87_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C87_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C87_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C87_REG_OFFSET 0xda0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C87_REG_OFFSET 0xda4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C87_REG_OFFSET 0xda8
#define SCMI_CHANNEL_FLAGS_C87_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C87_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C87_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C87_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C87_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C87_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C87_REG_OFFSET 0xdac

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C87_REG_OFFSET 0xdb0
#define SCMI_MESSAGE_HEADER_C87_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C87_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C87_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C87_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C87_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C87_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C87_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C87_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C87_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C87_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C87_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C87_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C87_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C87_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C87_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C87_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C87_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C87_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C87_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C87_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C87_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C87_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C87_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C87_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C87_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C87_REG_OFFSET 0xdb4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C87_REG_OFFSET 0xdb8
#define SCMI_DOORBELL_C87_INTR_BIT 0
#define SCMI_DOORBELL_C87_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C87_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C87_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C87_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C87_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C87_REG_OFFSET 0xdbc
#define SCMI_COMPLETION_INTERRUPT_C87_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C87_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C87_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C87_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C87_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C87_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C88_REG_OFFSET 0xdc0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C88_REG_OFFSET 0xdc4
#define SCMI_CHANNEL_STATUS_C88_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C88_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C88_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C88_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C88_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C88_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C88_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C88_REG_OFFSET 0xdc8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C88_REG_OFFSET 0xdcc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C88_REG_OFFSET 0xdd0
#define SCMI_CHANNEL_FLAGS_C88_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C88_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C88_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C88_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C88_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C88_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C88_REG_OFFSET 0xdd4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C88_REG_OFFSET 0xdd8
#define SCMI_MESSAGE_HEADER_C88_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C88_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C88_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C88_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C88_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C88_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C88_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C88_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C88_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C88_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C88_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C88_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C88_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C88_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C88_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C88_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C88_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C88_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C88_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C88_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C88_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C88_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C88_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C88_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C88_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C88_REG_OFFSET 0xddc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C88_REG_OFFSET 0xde0
#define SCMI_DOORBELL_C88_INTR_BIT 0
#define SCMI_DOORBELL_C88_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C88_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C88_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C88_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C88_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C88_REG_OFFSET 0xde4
#define SCMI_COMPLETION_INTERRUPT_C88_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C88_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C88_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C88_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C88_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C88_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C89_REG_OFFSET 0xde8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C89_REG_OFFSET 0xdec
#define SCMI_CHANNEL_STATUS_C89_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C89_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C89_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C89_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C89_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C89_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C89_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C89_REG_OFFSET 0xdf0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C89_REG_OFFSET 0xdf4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C89_REG_OFFSET 0xdf8
#define SCMI_CHANNEL_FLAGS_C89_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C89_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C89_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C89_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C89_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C89_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C89_REG_OFFSET 0xdfc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C89_REG_OFFSET 0xe00
#define SCMI_MESSAGE_HEADER_C89_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C89_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C89_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C89_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C89_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C89_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C89_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C89_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C89_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C89_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C89_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C89_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C89_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C89_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C89_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C89_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C89_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C89_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C89_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C89_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C89_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C89_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C89_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C89_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C89_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C89_REG_OFFSET 0xe04

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C89_REG_OFFSET 0xe08
#define SCMI_DOORBELL_C89_INTR_BIT 0
#define SCMI_DOORBELL_C89_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C89_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C89_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C89_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C89_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C89_REG_OFFSET 0xe0c
#define SCMI_COMPLETION_INTERRUPT_C89_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C89_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C89_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C89_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C89_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C89_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C90_REG_OFFSET 0xe10

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C90_REG_OFFSET 0xe14
#define SCMI_CHANNEL_STATUS_C90_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C90_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C90_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C90_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C90_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C90_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C90_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C90_REG_OFFSET 0xe18

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C90_REG_OFFSET 0xe1c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C90_REG_OFFSET 0xe20
#define SCMI_CHANNEL_FLAGS_C90_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C90_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C90_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C90_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C90_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C90_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C90_REG_OFFSET 0xe24

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C90_REG_OFFSET 0xe28
#define SCMI_MESSAGE_HEADER_C90_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C90_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C90_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C90_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C90_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C90_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C90_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C90_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C90_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C90_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C90_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C90_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C90_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C90_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C90_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C90_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C90_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C90_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C90_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C90_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C90_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C90_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C90_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C90_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C90_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C90_REG_OFFSET 0xe2c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C90_REG_OFFSET 0xe30
#define SCMI_DOORBELL_C90_INTR_BIT 0
#define SCMI_DOORBELL_C90_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C90_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C90_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C90_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C90_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C90_REG_OFFSET 0xe34
#define SCMI_COMPLETION_INTERRUPT_C90_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C90_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C90_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C90_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C90_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C90_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C91_REG_OFFSET 0xe38

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C91_REG_OFFSET 0xe3c
#define SCMI_CHANNEL_STATUS_C91_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C91_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C91_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C91_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C91_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C91_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C91_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C91_REG_OFFSET 0xe40

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C91_REG_OFFSET 0xe44

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C91_REG_OFFSET 0xe48
#define SCMI_CHANNEL_FLAGS_C91_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C91_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C91_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C91_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C91_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C91_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C91_REG_OFFSET 0xe4c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C91_REG_OFFSET 0xe50
#define SCMI_MESSAGE_HEADER_C91_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C91_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C91_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C91_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C91_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C91_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C91_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C91_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C91_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C91_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C91_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C91_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C91_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C91_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C91_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C91_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C91_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C91_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C91_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C91_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C91_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C91_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C91_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C91_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C91_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C91_REG_OFFSET 0xe54

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C91_REG_OFFSET 0xe58
#define SCMI_DOORBELL_C91_INTR_BIT 0
#define SCMI_DOORBELL_C91_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C91_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C91_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C91_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C91_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C91_REG_OFFSET 0xe5c
#define SCMI_COMPLETION_INTERRUPT_C91_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C91_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C91_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C91_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C91_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C91_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C92_REG_OFFSET 0xe60

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C92_REG_OFFSET 0xe64
#define SCMI_CHANNEL_STATUS_C92_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C92_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C92_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C92_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C92_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C92_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C92_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C92_REG_OFFSET 0xe68

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C92_REG_OFFSET 0xe6c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C92_REG_OFFSET 0xe70
#define SCMI_CHANNEL_FLAGS_C92_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C92_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C92_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C92_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C92_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C92_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C92_REG_OFFSET 0xe74

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C92_REG_OFFSET 0xe78
#define SCMI_MESSAGE_HEADER_C92_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C92_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C92_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C92_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C92_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C92_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C92_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C92_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C92_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C92_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C92_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C92_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C92_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C92_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C92_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C92_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C92_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C92_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C92_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C92_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C92_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C92_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C92_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C92_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C92_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C92_REG_OFFSET 0xe7c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C92_REG_OFFSET 0xe80
#define SCMI_DOORBELL_C92_INTR_BIT 0
#define SCMI_DOORBELL_C92_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C92_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C92_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C92_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C92_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C92_REG_OFFSET 0xe84
#define SCMI_COMPLETION_INTERRUPT_C92_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C92_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C92_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C92_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C92_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C92_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C93_REG_OFFSET 0xe88

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C93_REG_OFFSET 0xe8c
#define SCMI_CHANNEL_STATUS_C93_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C93_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C93_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C93_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C93_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C93_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C93_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C93_REG_OFFSET 0xe90

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C93_REG_OFFSET 0xe94

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C93_REG_OFFSET 0xe98
#define SCMI_CHANNEL_FLAGS_C93_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C93_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C93_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C93_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C93_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C93_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C93_REG_OFFSET 0xe9c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C93_REG_OFFSET 0xea0
#define SCMI_MESSAGE_HEADER_C93_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C93_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C93_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C93_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C93_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C93_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C93_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C93_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C93_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C93_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C93_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C93_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C93_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C93_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C93_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C93_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C93_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C93_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C93_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C93_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C93_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C93_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C93_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C93_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C93_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C93_REG_OFFSET 0xea4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C93_REG_OFFSET 0xea8
#define SCMI_DOORBELL_C93_INTR_BIT 0
#define SCMI_DOORBELL_C93_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C93_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C93_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C93_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C93_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C93_REG_OFFSET 0xeac
#define SCMI_COMPLETION_INTERRUPT_C93_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C93_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C93_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C93_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C93_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C93_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C94_REG_OFFSET 0xeb0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C94_REG_OFFSET 0xeb4
#define SCMI_CHANNEL_STATUS_C94_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C94_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C94_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C94_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C94_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C94_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C94_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C94_REG_OFFSET 0xeb8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C94_REG_OFFSET 0xebc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C94_REG_OFFSET 0xec0
#define SCMI_CHANNEL_FLAGS_C94_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C94_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C94_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C94_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C94_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C94_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C94_REG_OFFSET 0xec4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C94_REG_OFFSET 0xec8
#define SCMI_MESSAGE_HEADER_C94_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C94_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C94_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C94_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C94_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C94_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C94_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C94_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C94_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C94_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C94_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C94_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C94_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C94_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C94_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C94_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C94_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C94_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C94_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C94_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C94_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C94_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C94_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C94_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C94_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C94_REG_OFFSET 0xecc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C94_REG_OFFSET 0xed0
#define SCMI_DOORBELL_C94_INTR_BIT 0
#define SCMI_DOORBELL_C94_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C94_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C94_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C94_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C94_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C94_REG_OFFSET 0xed4
#define SCMI_COMPLETION_INTERRUPT_C94_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C94_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C94_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C94_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C94_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C94_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C95_REG_OFFSET 0xed8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C95_REG_OFFSET 0xedc
#define SCMI_CHANNEL_STATUS_C95_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C95_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C95_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C95_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C95_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C95_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C95_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C95_REG_OFFSET 0xee0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C95_REG_OFFSET 0xee4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C95_REG_OFFSET 0xee8
#define SCMI_CHANNEL_FLAGS_C95_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C95_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C95_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C95_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C95_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C95_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C95_REG_OFFSET 0xeec

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C95_REG_OFFSET 0xef0
#define SCMI_MESSAGE_HEADER_C95_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C95_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C95_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C95_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C95_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C95_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C95_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C95_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C95_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C95_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C95_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C95_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C95_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C95_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C95_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C95_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C95_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C95_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C95_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C95_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C95_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C95_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C95_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C95_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C95_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C95_REG_OFFSET 0xef4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C95_REG_OFFSET 0xef8
#define SCMI_DOORBELL_C95_INTR_BIT 0
#define SCMI_DOORBELL_C95_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C95_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C95_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C95_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C95_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C95_REG_OFFSET 0xefc
#define SCMI_COMPLETION_INTERRUPT_C95_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C95_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C95_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C95_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C95_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C95_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C96_REG_OFFSET 0xf00

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C96_REG_OFFSET 0xf04
#define SCMI_CHANNEL_STATUS_C96_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C96_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C96_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C96_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C96_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C96_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C96_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C96_REG_OFFSET 0xf08

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C96_REG_OFFSET 0xf0c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C96_REG_OFFSET 0xf10
#define SCMI_CHANNEL_FLAGS_C96_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C96_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C96_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C96_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C96_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C96_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C96_REG_OFFSET 0xf14

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C96_REG_OFFSET 0xf18
#define SCMI_MESSAGE_HEADER_C96_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C96_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C96_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C96_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C96_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C96_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C96_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C96_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C96_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C96_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C96_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C96_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C96_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C96_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C96_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C96_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C96_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C96_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C96_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C96_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C96_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C96_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C96_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C96_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C96_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C96_REG_OFFSET 0xf1c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C96_REG_OFFSET 0xf20
#define SCMI_DOORBELL_C96_INTR_BIT 0
#define SCMI_DOORBELL_C96_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C96_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C96_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C96_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C96_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C96_REG_OFFSET 0xf24
#define SCMI_COMPLETION_INTERRUPT_C96_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C96_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C96_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C96_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C96_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C96_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C97_REG_OFFSET 0xf28

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C97_REG_OFFSET 0xf2c
#define SCMI_CHANNEL_STATUS_C97_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C97_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C97_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C97_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C97_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C97_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C97_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C97_REG_OFFSET 0xf30

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C97_REG_OFFSET 0xf34

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C97_REG_OFFSET 0xf38
#define SCMI_CHANNEL_FLAGS_C97_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C97_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C97_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C97_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C97_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C97_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C97_REG_OFFSET 0xf3c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C97_REG_OFFSET 0xf40
#define SCMI_MESSAGE_HEADER_C97_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C97_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C97_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C97_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C97_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C97_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C97_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C97_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C97_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C97_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C97_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C97_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C97_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C97_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C97_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C97_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C97_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C97_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C97_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C97_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C97_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C97_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C97_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C97_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C97_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C97_REG_OFFSET 0xf44

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C97_REG_OFFSET 0xf48
#define SCMI_DOORBELL_C97_INTR_BIT 0
#define SCMI_DOORBELL_C97_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C97_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C97_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C97_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C97_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C97_REG_OFFSET 0xf4c
#define SCMI_COMPLETION_INTERRUPT_C97_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C97_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C97_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C97_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C97_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C97_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C98_REG_OFFSET 0xf50

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C98_REG_OFFSET 0xf54
#define SCMI_CHANNEL_STATUS_C98_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C98_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C98_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C98_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C98_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C98_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C98_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C98_REG_OFFSET 0xf58

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C98_REG_OFFSET 0xf5c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C98_REG_OFFSET 0xf60
#define SCMI_CHANNEL_FLAGS_C98_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C98_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C98_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C98_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C98_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C98_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C98_REG_OFFSET 0xf64

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C98_REG_OFFSET 0xf68
#define SCMI_MESSAGE_HEADER_C98_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C98_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C98_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C98_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C98_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C98_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C98_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C98_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C98_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C98_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C98_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C98_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C98_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C98_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C98_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C98_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C98_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C98_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C98_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C98_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C98_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C98_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C98_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C98_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C98_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C98_REG_OFFSET 0xf6c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C98_REG_OFFSET 0xf70
#define SCMI_DOORBELL_C98_INTR_BIT 0
#define SCMI_DOORBELL_C98_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C98_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C98_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C98_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C98_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C98_REG_OFFSET 0xf74
#define SCMI_COMPLETION_INTERRUPT_C98_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C98_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C98_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C98_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C98_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C98_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C99_REG_OFFSET 0xf78

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C99_REG_OFFSET 0xf7c
#define SCMI_CHANNEL_STATUS_C99_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C99_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C99_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C99_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C99_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C99_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C99_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C99_REG_OFFSET 0xf80

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C99_REG_OFFSET 0xf84

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C99_REG_OFFSET 0xf88
#define SCMI_CHANNEL_FLAGS_C99_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C99_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C99_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C99_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C99_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C99_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C99_REG_OFFSET 0xf8c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C99_REG_OFFSET 0xf90
#define SCMI_MESSAGE_HEADER_C99_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C99_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C99_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C99_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C99_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C99_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C99_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C99_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C99_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C99_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C99_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C99_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C99_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C99_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C99_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C99_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C99_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C99_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C99_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C99_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C99_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C99_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C99_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C99_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C99_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C99_REG_OFFSET 0xf94

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C99_REG_OFFSET 0xf98
#define SCMI_DOORBELL_C99_INTR_BIT 0
#define SCMI_DOORBELL_C99_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C99_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C99_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C99_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C99_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C99_REG_OFFSET 0xf9c
#define SCMI_COMPLETION_INTERRUPT_C99_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C99_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C99_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C99_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C99_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C99_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C100_REG_OFFSET 0xfa0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C100_REG_OFFSET 0xfa4
#define SCMI_CHANNEL_STATUS_C100_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C100_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C100_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C100_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C100_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C100_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C100_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C100_REG_OFFSET 0xfa8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C100_REG_OFFSET 0xfac

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C100_REG_OFFSET 0xfb0
#define SCMI_CHANNEL_FLAGS_C100_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C100_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C100_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C100_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C100_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C100_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C100_REG_OFFSET 0xfb4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C100_REG_OFFSET 0xfb8
#define SCMI_MESSAGE_HEADER_C100_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C100_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C100_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C100_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C100_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C100_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C100_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C100_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C100_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C100_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C100_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C100_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C100_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C100_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C100_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C100_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C100_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C100_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C100_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C100_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C100_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C100_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C100_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C100_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C100_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C100_REG_OFFSET 0xfbc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C100_REG_OFFSET 0xfc0
#define SCMI_DOORBELL_C100_INTR_BIT 0
#define SCMI_DOORBELL_C100_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C100_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C100_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C100_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C100_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C100_REG_OFFSET 0xfc4
#define SCMI_COMPLETION_INTERRUPT_C100_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C100_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C100_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C100_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C100_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C100_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C101_REG_OFFSET 0xfc8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C101_REG_OFFSET 0xfcc
#define SCMI_CHANNEL_STATUS_C101_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C101_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C101_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C101_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C101_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C101_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C101_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C101_REG_OFFSET 0xfd0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C101_REG_OFFSET 0xfd4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C101_REG_OFFSET 0xfd8
#define SCMI_CHANNEL_FLAGS_C101_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C101_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C101_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C101_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C101_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C101_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C101_REG_OFFSET 0xfdc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C101_REG_OFFSET 0xfe0
#define SCMI_MESSAGE_HEADER_C101_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C101_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C101_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C101_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C101_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C101_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C101_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C101_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C101_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C101_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C101_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C101_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C101_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C101_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C101_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C101_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C101_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C101_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C101_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C101_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C101_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C101_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C101_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C101_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C101_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C101_REG_OFFSET 0xfe4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C101_REG_OFFSET 0xfe8
#define SCMI_DOORBELL_C101_INTR_BIT 0
#define SCMI_DOORBELL_C101_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C101_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C101_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C101_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C101_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C101_REG_OFFSET 0xfec
#define SCMI_COMPLETION_INTERRUPT_C101_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C101_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C101_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C101_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C101_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C101_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C102_REG_OFFSET 0xff0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C102_REG_OFFSET 0xff4
#define SCMI_CHANNEL_STATUS_C102_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C102_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C102_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C102_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C102_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C102_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C102_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C102_REG_OFFSET 0xff8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C102_REG_OFFSET 0xffc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C102_REG_OFFSET 0x1000
#define SCMI_CHANNEL_FLAGS_C102_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C102_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C102_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C102_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C102_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C102_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C102_REG_OFFSET 0x1004

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C102_REG_OFFSET 0x1008
#define SCMI_MESSAGE_HEADER_C102_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C102_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C102_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C102_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C102_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C102_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C102_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C102_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C102_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C102_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C102_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C102_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C102_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C102_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C102_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C102_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C102_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C102_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C102_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C102_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C102_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C102_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C102_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C102_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C102_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C102_REG_OFFSET 0x100c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C102_REG_OFFSET 0x1010
#define SCMI_DOORBELL_C102_INTR_BIT 0
#define SCMI_DOORBELL_C102_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C102_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C102_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C102_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C102_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C102_REG_OFFSET 0x1014
#define SCMI_COMPLETION_INTERRUPT_C102_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C102_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C102_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C102_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C102_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C102_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C103_REG_OFFSET 0x1018

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C103_REG_OFFSET 0x101c
#define SCMI_CHANNEL_STATUS_C103_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C103_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C103_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C103_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C103_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C103_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C103_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C103_REG_OFFSET 0x1020

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C103_REG_OFFSET 0x1024

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C103_REG_OFFSET 0x1028
#define SCMI_CHANNEL_FLAGS_C103_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C103_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C103_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C103_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C103_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C103_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C103_REG_OFFSET 0x102c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C103_REG_OFFSET 0x1030
#define SCMI_MESSAGE_HEADER_C103_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C103_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C103_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C103_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C103_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C103_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C103_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C103_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C103_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C103_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C103_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C103_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C103_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C103_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C103_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C103_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C103_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C103_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C103_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C103_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C103_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C103_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C103_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C103_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C103_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C103_REG_OFFSET 0x1034

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C103_REG_OFFSET 0x1038
#define SCMI_DOORBELL_C103_INTR_BIT 0
#define SCMI_DOORBELL_C103_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C103_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C103_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C103_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C103_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C103_REG_OFFSET 0x103c
#define SCMI_COMPLETION_INTERRUPT_C103_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C103_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C103_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C103_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C103_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C103_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C104_REG_OFFSET 0x1040

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C104_REG_OFFSET 0x1044
#define SCMI_CHANNEL_STATUS_C104_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C104_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C104_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C104_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C104_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C104_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C104_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C104_REG_OFFSET 0x1048

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C104_REG_OFFSET 0x104c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C104_REG_OFFSET 0x1050
#define SCMI_CHANNEL_FLAGS_C104_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C104_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C104_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C104_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C104_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C104_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C104_REG_OFFSET 0x1054

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C104_REG_OFFSET 0x1058
#define SCMI_MESSAGE_HEADER_C104_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C104_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C104_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C104_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C104_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C104_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C104_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C104_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C104_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C104_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C104_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C104_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C104_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C104_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C104_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C104_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C104_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C104_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C104_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C104_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C104_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C104_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C104_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C104_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C104_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C104_REG_OFFSET 0x105c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C104_REG_OFFSET 0x1060
#define SCMI_DOORBELL_C104_INTR_BIT 0
#define SCMI_DOORBELL_C104_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C104_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C104_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C104_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C104_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C104_REG_OFFSET 0x1064
#define SCMI_COMPLETION_INTERRUPT_C104_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C104_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C104_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C104_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C104_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C104_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C105_REG_OFFSET 0x1068

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C105_REG_OFFSET 0x106c
#define SCMI_CHANNEL_STATUS_C105_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C105_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C105_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C105_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C105_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C105_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C105_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C105_REG_OFFSET 0x1070

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C105_REG_OFFSET 0x1074

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C105_REG_OFFSET 0x1078
#define SCMI_CHANNEL_FLAGS_C105_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C105_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C105_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C105_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C105_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C105_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C105_REG_OFFSET 0x107c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C105_REG_OFFSET 0x1080
#define SCMI_MESSAGE_HEADER_C105_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C105_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C105_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C105_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C105_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C105_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C105_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C105_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C105_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C105_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C105_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C105_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C105_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C105_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C105_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C105_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C105_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C105_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C105_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C105_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C105_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C105_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C105_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C105_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C105_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C105_REG_OFFSET 0x1084

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C105_REG_OFFSET 0x1088
#define SCMI_DOORBELL_C105_INTR_BIT 0
#define SCMI_DOORBELL_C105_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C105_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C105_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C105_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C105_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C105_REG_OFFSET 0x108c
#define SCMI_COMPLETION_INTERRUPT_C105_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C105_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C105_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C105_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C105_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C105_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C106_REG_OFFSET 0x1090

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C106_REG_OFFSET 0x1094
#define SCMI_CHANNEL_STATUS_C106_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C106_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C106_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C106_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C106_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C106_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C106_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C106_REG_OFFSET 0x1098

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C106_REG_OFFSET 0x109c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C106_REG_OFFSET 0x10a0
#define SCMI_CHANNEL_FLAGS_C106_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C106_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C106_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C106_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C106_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C106_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C106_REG_OFFSET 0x10a4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C106_REG_OFFSET 0x10a8
#define SCMI_MESSAGE_HEADER_C106_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C106_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C106_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C106_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C106_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C106_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C106_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C106_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C106_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C106_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C106_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C106_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C106_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C106_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C106_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C106_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C106_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C106_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C106_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C106_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C106_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C106_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C106_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C106_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C106_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C106_REG_OFFSET 0x10ac

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C106_REG_OFFSET 0x10b0
#define SCMI_DOORBELL_C106_INTR_BIT 0
#define SCMI_DOORBELL_C106_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C106_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C106_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C106_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C106_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C106_REG_OFFSET 0x10b4
#define SCMI_COMPLETION_INTERRUPT_C106_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C106_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C106_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C106_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C106_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C106_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C107_REG_OFFSET 0x10b8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C107_REG_OFFSET 0x10bc
#define SCMI_CHANNEL_STATUS_C107_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C107_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C107_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C107_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C107_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C107_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C107_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C107_REG_OFFSET 0x10c0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C107_REG_OFFSET 0x10c4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C107_REG_OFFSET 0x10c8
#define SCMI_CHANNEL_FLAGS_C107_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C107_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C107_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C107_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C107_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C107_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C107_REG_OFFSET 0x10cc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C107_REG_OFFSET 0x10d0
#define SCMI_MESSAGE_HEADER_C107_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C107_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C107_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C107_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C107_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C107_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C107_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C107_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C107_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C107_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C107_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C107_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C107_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C107_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C107_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C107_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C107_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C107_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C107_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C107_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C107_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C107_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C107_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C107_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C107_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C107_REG_OFFSET 0x10d4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C107_REG_OFFSET 0x10d8
#define SCMI_DOORBELL_C107_INTR_BIT 0
#define SCMI_DOORBELL_C107_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C107_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C107_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C107_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C107_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C107_REG_OFFSET 0x10dc
#define SCMI_COMPLETION_INTERRUPT_C107_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C107_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C107_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C107_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C107_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C107_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C108_REG_OFFSET 0x10e0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C108_REG_OFFSET 0x10e4
#define SCMI_CHANNEL_STATUS_C108_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C108_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C108_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C108_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C108_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C108_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C108_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C108_REG_OFFSET 0x10e8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C108_REG_OFFSET 0x10ec

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C108_REG_OFFSET 0x10f0
#define SCMI_CHANNEL_FLAGS_C108_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C108_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C108_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C108_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C108_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C108_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C108_REG_OFFSET 0x10f4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C108_REG_OFFSET 0x10f8
#define SCMI_MESSAGE_HEADER_C108_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C108_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C108_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C108_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C108_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C108_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C108_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C108_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C108_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C108_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C108_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C108_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C108_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C108_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C108_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C108_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C108_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C108_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C108_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C108_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C108_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C108_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C108_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C108_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C108_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C108_REG_OFFSET 0x10fc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C108_REG_OFFSET 0x1100
#define SCMI_DOORBELL_C108_INTR_BIT 0
#define SCMI_DOORBELL_C108_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C108_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C108_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C108_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C108_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C108_REG_OFFSET 0x1104
#define SCMI_COMPLETION_INTERRUPT_C108_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C108_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C108_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C108_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C108_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C108_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C109_REG_OFFSET 0x1108

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C109_REG_OFFSET 0x110c
#define SCMI_CHANNEL_STATUS_C109_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C109_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C109_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C109_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C109_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C109_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C109_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C109_REG_OFFSET 0x1110

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C109_REG_OFFSET 0x1114

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C109_REG_OFFSET 0x1118
#define SCMI_CHANNEL_FLAGS_C109_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C109_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C109_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C109_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C109_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C109_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C109_REG_OFFSET 0x111c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C109_REG_OFFSET 0x1120
#define SCMI_MESSAGE_HEADER_C109_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C109_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C109_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C109_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C109_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C109_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C109_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C109_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C109_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C109_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C109_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C109_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C109_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C109_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C109_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C109_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C109_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C109_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C109_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C109_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C109_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C109_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C109_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C109_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C109_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C109_REG_OFFSET 0x1124

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C109_REG_OFFSET 0x1128
#define SCMI_DOORBELL_C109_INTR_BIT 0
#define SCMI_DOORBELL_C109_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C109_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C109_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C109_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C109_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C109_REG_OFFSET 0x112c
#define SCMI_COMPLETION_INTERRUPT_C109_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C109_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C109_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C109_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C109_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C109_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C110_REG_OFFSET 0x1130

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C110_REG_OFFSET 0x1134
#define SCMI_CHANNEL_STATUS_C110_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C110_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C110_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C110_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C110_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C110_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C110_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C110_REG_OFFSET 0x1138

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C110_REG_OFFSET 0x113c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C110_REG_OFFSET 0x1140
#define SCMI_CHANNEL_FLAGS_C110_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C110_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C110_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C110_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C110_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C110_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C110_REG_OFFSET 0x1144

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C110_REG_OFFSET 0x1148
#define SCMI_MESSAGE_HEADER_C110_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C110_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C110_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C110_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C110_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C110_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C110_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C110_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C110_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C110_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C110_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C110_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C110_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C110_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C110_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C110_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C110_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C110_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C110_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C110_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C110_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C110_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C110_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C110_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C110_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C110_REG_OFFSET 0x114c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C110_REG_OFFSET 0x1150
#define SCMI_DOORBELL_C110_INTR_BIT 0
#define SCMI_DOORBELL_C110_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C110_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C110_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C110_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C110_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C110_REG_OFFSET 0x1154
#define SCMI_COMPLETION_INTERRUPT_C110_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C110_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C110_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C110_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C110_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C110_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C111_REG_OFFSET 0x1158

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C111_REG_OFFSET 0x115c
#define SCMI_CHANNEL_STATUS_C111_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C111_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C111_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C111_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C111_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C111_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C111_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C111_REG_OFFSET 0x1160

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C111_REG_OFFSET 0x1164

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C111_REG_OFFSET 0x1168
#define SCMI_CHANNEL_FLAGS_C111_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C111_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C111_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C111_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C111_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C111_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C111_REG_OFFSET 0x116c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C111_REG_OFFSET 0x1170
#define SCMI_MESSAGE_HEADER_C111_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C111_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C111_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C111_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C111_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C111_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C111_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C111_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C111_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C111_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C111_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C111_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C111_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C111_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C111_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C111_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C111_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C111_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C111_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C111_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C111_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C111_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C111_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C111_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C111_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C111_REG_OFFSET 0x1174

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C111_REG_OFFSET 0x1178
#define SCMI_DOORBELL_C111_INTR_BIT 0
#define SCMI_DOORBELL_C111_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C111_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C111_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C111_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C111_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C111_REG_OFFSET 0x117c
#define SCMI_COMPLETION_INTERRUPT_C111_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C111_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C111_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C111_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C111_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C111_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C112_REG_OFFSET 0x1180

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C112_REG_OFFSET 0x1184
#define SCMI_CHANNEL_STATUS_C112_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C112_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C112_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C112_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C112_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C112_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C112_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C112_REG_OFFSET 0x1188

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C112_REG_OFFSET 0x118c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C112_REG_OFFSET 0x1190
#define SCMI_CHANNEL_FLAGS_C112_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C112_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C112_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C112_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C112_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C112_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C112_REG_OFFSET 0x1194

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C112_REG_OFFSET 0x1198
#define SCMI_MESSAGE_HEADER_C112_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C112_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C112_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C112_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C112_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C112_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C112_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C112_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C112_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C112_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C112_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C112_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C112_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C112_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C112_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C112_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C112_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C112_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C112_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C112_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C112_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C112_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C112_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C112_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C112_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C112_REG_OFFSET 0x119c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C112_REG_OFFSET 0x11a0
#define SCMI_DOORBELL_C112_INTR_BIT 0
#define SCMI_DOORBELL_C112_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C112_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C112_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C112_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C112_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C112_REG_OFFSET 0x11a4
#define SCMI_COMPLETION_INTERRUPT_C112_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C112_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C112_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C112_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C112_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C112_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C113_REG_OFFSET 0x11a8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C113_REG_OFFSET 0x11ac
#define SCMI_CHANNEL_STATUS_C113_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C113_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C113_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C113_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C113_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C113_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C113_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C113_REG_OFFSET 0x11b0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C113_REG_OFFSET 0x11b4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C113_REG_OFFSET 0x11b8
#define SCMI_CHANNEL_FLAGS_C113_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C113_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C113_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C113_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C113_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C113_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C113_REG_OFFSET 0x11bc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C113_REG_OFFSET 0x11c0
#define SCMI_MESSAGE_HEADER_C113_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C113_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C113_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C113_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C113_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C113_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C113_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C113_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C113_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C113_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C113_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C113_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C113_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C113_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C113_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C113_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C113_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C113_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C113_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C113_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C113_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C113_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C113_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C113_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C113_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C113_REG_OFFSET 0x11c4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C113_REG_OFFSET 0x11c8
#define SCMI_DOORBELL_C113_INTR_BIT 0
#define SCMI_DOORBELL_C113_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C113_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C113_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C113_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C113_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C113_REG_OFFSET 0x11cc
#define SCMI_COMPLETION_INTERRUPT_C113_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C113_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C113_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C113_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C113_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C113_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C114_REG_OFFSET 0x11d0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C114_REG_OFFSET 0x11d4
#define SCMI_CHANNEL_STATUS_C114_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C114_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C114_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C114_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C114_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C114_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C114_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C114_REG_OFFSET 0x11d8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C114_REG_OFFSET 0x11dc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C114_REG_OFFSET 0x11e0
#define SCMI_CHANNEL_FLAGS_C114_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C114_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C114_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C114_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C114_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C114_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C114_REG_OFFSET 0x11e4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C114_REG_OFFSET 0x11e8
#define SCMI_MESSAGE_HEADER_C114_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C114_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C114_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C114_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C114_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C114_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C114_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C114_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C114_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C114_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C114_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C114_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C114_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C114_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C114_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C114_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C114_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C114_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C114_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C114_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C114_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C114_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C114_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C114_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C114_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C114_REG_OFFSET 0x11ec

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C114_REG_OFFSET 0x11f0
#define SCMI_DOORBELL_C114_INTR_BIT 0
#define SCMI_DOORBELL_C114_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C114_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C114_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C114_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C114_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C114_REG_OFFSET 0x11f4
#define SCMI_COMPLETION_INTERRUPT_C114_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C114_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C114_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C114_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C114_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C114_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C115_REG_OFFSET 0x11f8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C115_REG_OFFSET 0x11fc
#define SCMI_CHANNEL_STATUS_C115_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C115_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C115_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C115_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C115_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C115_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C115_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C115_REG_OFFSET 0x1200

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C115_REG_OFFSET 0x1204

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C115_REG_OFFSET 0x1208
#define SCMI_CHANNEL_FLAGS_C115_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C115_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C115_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C115_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C115_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C115_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C115_REG_OFFSET 0x120c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C115_REG_OFFSET 0x1210
#define SCMI_MESSAGE_HEADER_C115_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C115_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C115_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C115_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C115_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C115_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C115_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C115_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C115_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C115_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C115_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C115_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C115_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C115_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C115_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C115_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C115_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C115_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C115_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C115_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C115_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C115_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C115_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C115_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C115_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C115_REG_OFFSET 0x1214

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C115_REG_OFFSET 0x1218
#define SCMI_DOORBELL_C115_INTR_BIT 0
#define SCMI_DOORBELL_C115_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C115_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C115_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C115_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C115_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C115_REG_OFFSET 0x121c
#define SCMI_COMPLETION_INTERRUPT_C115_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C115_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C115_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C115_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C115_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C115_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C116_REG_OFFSET 0x1220

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C116_REG_OFFSET 0x1224
#define SCMI_CHANNEL_STATUS_C116_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C116_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C116_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C116_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C116_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C116_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C116_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C116_REG_OFFSET 0x1228

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C116_REG_OFFSET 0x122c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C116_REG_OFFSET 0x1230
#define SCMI_CHANNEL_FLAGS_C116_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C116_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C116_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C116_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C116_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C116_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C116_REG_OFFSET 0x1234

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C116_REG_OFFSET 0x1238
#define SCMI_MESSAGE_HEADER_C116_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C116_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C116_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C116_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C116_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C116_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C116_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C116_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C116_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C116_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C116_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C116_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C116_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C116_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C116_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C116_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C116_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C116_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C116_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C116_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C116_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C116_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C116_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C116_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C116_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C116_REG_OFFSET 0x123c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C116_REG_OFFSET 0x1240
#define SCMI_DOORBELL_C116_INTR_BIT 0
#define SCMI_DOORBELL_C116_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C116_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C116_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C116_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C116_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C116_REG_OFFSET 0x1244
#define SCMI_COMPLETION_INTERRUPT_C116_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C116_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C116_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C116_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C116_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C116_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C117_REG_OFFSET 0x1248

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C117_REG_OFFSET 0x124c
#define SCMI_CHANNEL_STATUS_C117_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C117_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C117_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C117_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C117_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C117_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C117_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C117_REG_OFFSET 0x1250

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C117_REG_OFFSET 0x1254

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C117_REG_OFFSET 0x1258
#define SCMI_CHANNEL_FLAGS_C117_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C117_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C117_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C117_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C117_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C117_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C117_REG_OFFSET 0x125c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C117_REG_OFFSET 0x1260
#define SCMI_MESSAGE_HEADER_C117_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C117_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C117_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C117_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C117_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C117_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C117_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C117_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C117_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C117_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C117_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C117_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C117_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C117_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C117_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C117_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C117_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C117_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C117_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C117_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C117_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C117_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C117_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C117_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C117_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C117_REG_OFFSET 0x1264

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C117_REG_OFFSET 0x1268
#define SCMI_DOORBELL_C117_INTR_BIT 0
#define SCMI_DOORBELL_C117_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C117_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C117_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C117_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C117_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C117_REG_OFFSET 0x126c
#define SCMI_COMPLETION_INTERRUPT_C117_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C117_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C117_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C117_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C117_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C117_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C118_REG_OFFSET 0x1270

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C118_REG_OFFSET 0x1274
#define SCMI_CHANNEL_STATUS_C118_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C118_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C118_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C118_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C118_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C118_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C118_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C118_REG_OFFSET 0x1278

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C118_REG_OFFSET 0x127c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C118_REG_OFFSET 0x1280
#define SCMI_CHANNEL_FLAGS_C118_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C118_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C118_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C118_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C118_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C118_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C118_REG_OFFSET 0x1284

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C118_REG_OFFSET 0x1288
#define SCMI_MESSAGE_HEADER_C118_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C118_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C118_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C118_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C118_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C118_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C118_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C118_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C118_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C118_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C118_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C118_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C118_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C118_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C118_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C118_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C118_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C118_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C118_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C118_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C118_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C118_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C118_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C118_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C118_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C118_REG_OFFSET 0x128c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C118_REG_OFFSET 0x1290
#define SCMI_DOORBELL_C118_INTR_BIT 0
#define SCMI_DOORBELL_C118_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C118_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C118_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C118_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C118_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C118_REG_OFFSET 0x1294
#define SCMI_COMPLETION_INTERRUPT_C118_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C118_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C118_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C118_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C118_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C118_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C119_REG_OFFSET 0x1298

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C119_REG_OFFSET 0x129c
#define SCMI_CHANNEL_STATUS_C119_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C119_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C119_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C119_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C119_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C119_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C119_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C119_REG_OFFSET 0x12a0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C119_REG_OFFSET 0x12a4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C119_REG_OFFSET 0x12a8
#define SCMI_CHANNEL_FLAGS_C119_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C119_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C119_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C119_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C119_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C119_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C119_REG_OFFSET 0x12ac

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C119_REG_OFFSET 0x12b0
#define SCMI_MESSAGE_HEADER_C119_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C119_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C119_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C119_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C119_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C119_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C119_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C119_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C119_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C119_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C119_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C119_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C119_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C119_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C119_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C119_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C119_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C119_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C119_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C119_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C119_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C119_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C119_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C119_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C119_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C119_REG_OFFSET 0x12b4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C119_REG_OFFSET 0x12b8
#define SCMI_DOORBELL_C119_INTR_BIT 0
#define SCMI_DOORBELL_C119_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C119_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C119_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C119_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C119_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C119_REG_OFFSET 0x12bc
#define SCMI_COMPLETION_INTERRUPT_C119_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C119_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C119_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C119_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C119_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C119_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C120_REG_OFFSET 0x12c0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C120_REG_OFFSET 0x12c4
#define SCMI_CHANNEL_STATUS_C120_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C120_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C120_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C120_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C120_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C120_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C120_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C120_REG_OFFSET 0x12c8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C120_REG_OFFSET 0x12cc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C120_REG_OFFSET 0x12d0
#define SCMI_CHANNEL_FLAGS_C120_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C120_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C120_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C120_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C120_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C120_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C120_REG_OFFSET 0x12d4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C120_REG_OFFSET 0x12d8
#define SCMI_MESSAGE_HEADER_C120_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C120_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C120_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C120_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C120_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C120_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C120_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C120_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C120_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C120_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C120_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C120_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C120_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C120_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C120_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C120_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C120_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C120_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C120_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C120_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C120_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C120_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C120_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C120_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C120_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C120_REG_OFFSET 0x12dc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C120_REG_OFFSET 0x12e0
#define SCMI_DOORBELL_C120_INTR_BIT 0
#define SCMI_DOORBELL_C120_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C120_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C120_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C120_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C120_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C120_REG_OFFSET 0x12e4
#define SCMI_COMPLETION_INTERRUPT_C120_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C120_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C120_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C120_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C120_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C120_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C121_REG_OFFSET 0x12e8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C121_REG_OFFSET 0x12ec
#define SCMI_CHANNEL_STATUS_C121_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C121_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C121_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C121_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C121_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C121_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C121_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C121_REG_OFFSET 0x12f0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C121_REG_OFFSET 0x12f4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C121_REG_OFFSET 0x12f8
#define SCMI_CHANNEL_FLAGS_C121_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C121_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C121_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C121_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C121_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C121_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C121_REG_OFFSET 0x12fc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C121_REG_OFFSET 0x1300
#define SCMI_MESSAGE_HEADER_C121_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C121_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C121_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C121_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C121_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C121_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C121_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C121_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C121_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C121_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C121_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C121_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C121_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C121_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C121_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C121_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C121_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C121_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C121_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C121_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C121_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C121_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C121_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C121_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C121_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C121_REG_OFFSET 0x1304

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C121_REG_OFFSET 0x1308
#define SCMI_DOORBELL_C121_INTR_BIT 0
#define SCMI_DOORBELL_C121_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C121_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C121_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C121_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C121_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C121_REG_OFFSET 0x130c
#define SCMI_COMPLETION_INTERRUPT_C121_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C121_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C121_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C121_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C121_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C121_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C122_REG_OFFSET 0x1310

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C122_REG_OFFSET 0x1314
#define SCMI_CHANNEL_STATUS_C122_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C122_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C122_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C122_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C122_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C122_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C122_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C122_REG_OFFSET 0x1318

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C122_REG_OFFSET 0x131c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C122_REG_OFFSET 0x1320
#define SCMI_CHANNEL_FLAGS_C122_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C122_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C122_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C122_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C122_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C122_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C122_REG_OFFSET 0x1324

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C122_REG_OFFSET 0x1328
#define SCMI_MESSAGE_HEADER_C122_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C122_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C122_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C122_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C122_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C122_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C122_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C122_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C122_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C122_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C122_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C122_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C122_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C122_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C122_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C122_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C122_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C122_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C122_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C122_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C122_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C122_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C122_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C122_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C122_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C122_REG_OFFSET 0x132c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C122_REG_OFFSET 0x1330
#define SCMI_DOORBELL_C122_INTR_BIT 0
#define SCMI_DOORBELL_C122_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C122_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C122_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C122_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C122_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C122_REG_OFFSET 0x1334
#define SCMI_COMPLETION_INTERRUPT_C122_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C122_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C122_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C122_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C122_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C122_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C123_REG_OFFSET 0x1338

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C123_REG_OFFSET 0x133c
#define SCMI_CHANNEL_STATUS_C123_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C123_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C123_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C123_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C123_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C123_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C123_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C123_REG_OFFSET 0x1340

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C123_REG_OFFSET 0x1344

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C123_REG_OFFSET 0x1348
#define SCMI_CHANNEL_FLAGS_C123_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C123_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C123_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C123_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C123_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C123_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C123_REG_OFFSET 0x134c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C123_REG_OFFSET 0x1350
#define SCMI_MESSAGE_HEADER_C123_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C123_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C123_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C123_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C123_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C123_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C123_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C123_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C123_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C123_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C123_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C123_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C123_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C123_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C123_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C123_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C123_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C123_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C123_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C123_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C123_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C123_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C123_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C123_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C123_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C123_REG_OFFSET 0x1354

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C123_REG_OFFSET 0x1358
#define SCMI_DOORBELL_C123_INTR_BIT 0
#define SCMI_DOORBELL_C123_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C123_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C123_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C123_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C123_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C123_REG_OFFSET 0x135c
#define SCMI_COMPLETION_INTERRUPT_C123_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C123_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C123_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C123_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C123_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C123_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C124_REG_OFFSET 0x1360

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C124_REG_OFFSET 0x1364
#define SCMI_CHANNEL_STATUS_C124_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C124_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C124_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C124_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C124_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C124_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C124_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C124_REG_OFFSET 0x1368

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C124_REG_OFFSET 0x136c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C124_REG_OFFSET 0x1370
#define SCMI_CHANNEL_FLAGS_C124_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C124_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C124_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C124_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C124_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C124_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C124_REG_OFFSET 0x1374

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C124_REG_OFFSET 0x1378
#define SCMI_MESSAGE_HEADER_C124_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C124_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C124_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C124_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C124_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C124_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C124_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C124_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C124_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C124_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C124_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C124_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C124_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C124_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C124_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C124_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C124_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C124_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C124_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C124_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C124_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C124_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C124_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C124_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C124_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C124_REG_OFFSET 0x137c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C124_REG_OFFSET 0x1380
#define SCMI_DOORBELL_C124_INTR_BIT 0
#define SCMI_DOORBELL_C124_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C124_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C124_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C124_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C124_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C124_REG_OFFSET 0x1384
#define SCMI_COMPLETION_INTERRUPT_C124_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C124_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C124_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C124_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C124_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C124_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C125_REG_OFFSET 0x1388

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C125_REG_OFFSET 0x138c
#define SCMI_CHANNEL_STATUS_C125_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C125_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C125_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C125_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C125_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C125_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C125_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C125_REG_OFFSET 0x1390

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C125_REG_OFFSET 0x1394

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C125_REG_OFFSET 0x1398
#define SCMI_CHANNEL_FLAGS_C125_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C125_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C125_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C125_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C125_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C125_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C125_REG_OFFSET 0x139c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C125_REG_OFFSET 0x13a0
#define SCMI_MESSAGE_HEADER_C125_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C125_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C125_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C125_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C125_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C125_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C125_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C125_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C125_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C125_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C125_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C125_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C125_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C125_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C125_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C125_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C125_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C125_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C125_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C125_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C125_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C125_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C125_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C125_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C125_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C125_REG_OFFSET 0x13a4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C125_REG_OFFSET 0x13a8
#define SCMI_DOORBELL_C125_INTR_BIT 0
#define SCMI_DOORBELL_C125_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C125_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C125_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C125_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C125_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C125_REG_OFFSET 0x13ac
#define SCMI_COMPLETION_INTERRUPT_C125_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C125_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C125_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C125_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C125_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C125_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C126_REG_OFFSET 0x13b0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C126_REG_OFFSET 0x13b4
#define SCMI_CHANNEL_STATUS_C126_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C126_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C126_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C126_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C126_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C126_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C126_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C126_REG_OFFSET 0x13b8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C126_REG_OFFSET 0x13bc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C126_REG_OFFSET 0x13c0
#define SCMI_CHANNEL_FLAGS_C126_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C126_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C126_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C126_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C126_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C126_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C126_REG_OFFSET 0x13c4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C126_REG_OFFSET 0x13c8
#define SCMI_MESSAGE_HEADER_C126_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C126_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C126_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C126_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C126_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C126_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C126_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C126_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C126_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C126_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C126_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C126_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C126_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C126_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C126_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C126_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C126_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C126_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C126_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C126_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C126_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C126_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C126_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C126_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C126_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C126_REG_OFFSET 0x13cc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C126_REG_OFFSET 0x13d0
#define SCMI_DOORBELL_C126_INTR_BIT 0
#define SCMI_DOORBELL_C126_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C126_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C126_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C126_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C126_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C126_REG_OFFSET 0x13d4
#define SCMI_COMPLETION_INTERRUPT_C126_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C126_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C126_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C126_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C126_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C126_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C127_REG_OFFSET 0x13d8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C127_REG_OFFSET 0x13dc
#define SCMI_CHANNEL_STATUS_C127_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C127_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C127_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C127_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C127_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C127_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C127_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C127_REG_OFFSET 0x13e0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C127_REG_OFFSET 0x13e4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C127_REG_OFFSET 0x13e8
#define SCMI_CHANNEL_FLAGS_C127_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C127_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C127_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C127_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C127_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C127_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C127_REG_OFFSET 0x13ec

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C127_REG_OFFSET 0x13f0
#define SCMI_MESSAGE_HEADER_C127_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C127_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C127_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C127_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C127_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C127_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C127_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C127_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C127_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C127_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C127_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C127_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C127_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C127_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C127_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C127_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C127_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C127_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C127_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C127_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C127_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C127_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C127_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C127_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C127_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C127_REG_OFFSET 0x13f4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C127_REG_OFFSET 0x13f8
#define SCMI_DOORBELL_C127_INTR_BIT 0
#define SCMI_DOORBELL_C127_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C127_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C127_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C127_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C127_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C127_REG_OFFSET 0x13fc
#define SCMI_COMPLETION_INTERRUPT_C127_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C127_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C127_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C127_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C127_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C127_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C128_REG_OFFSET 0x1400

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C128_REG_OFFSET 0x1404
#define SCMI_CHANNEL_STATUS_C128_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C128_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C128_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C128_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C128_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C128_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C128_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C128_REG_OFFSET 0x1408

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C128_REG_OFFSET 0x140c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C128_REG_OFFSET 0x1410
#define SCMI_CHANNEL_FLAGS_C128_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C128_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C128_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C128_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C128_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C128_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C128_REG_OFFSET 0x1414

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C128_REG_OFFSET 0x1418
#define SCMI_MESSAGE_HEADER_C128_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C128_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C128_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C128_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C128_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C128_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C128_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C128_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C128_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C128_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C128_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C128_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C128_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C128_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C128_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C128_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C128_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C128_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C128_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C128_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C128_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C128_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C128_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C128_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C128_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C128_REG_OFFSET 0x141c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C128_REG_OFFSET 0x1420
#define SCMI_DOORBELL_C128_INTR_BIT 0
#define SCMI_DOORBELL_C128_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C128_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C128_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C128_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C128_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C128_REG_OFFSET 0x1424
#define SCMI_COMPLETION_INTERRUPT_C128_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C128_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C128_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C128_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C128_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C128_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C129_REG_OFFSET 0x1428

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C129_REG_OFFSET 0x142c
#define SCMI_CHANNEL_STATUS_C129_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C129_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C129_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C129_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C129_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C129_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C129_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C129_REG_OFFSET 0x1430

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C129_REG_OFFSET 0x1434

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C129_REG_OFFSET 0x1438
#define SCMI_CHANNEL_FLAGS_C129_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C129_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C129_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C129_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C129_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C129_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C129_REG_OFFSET 0x143c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C129_REG_OFFSET 0x1440
#define SCMI_MESSAGE_HEADER_C129_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C129_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C129_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C129_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C129_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C129_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C129_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C129_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C129_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C129_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C129_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C129_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C129_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C129_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C129_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C129_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C129_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C129_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C129_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C129_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C129_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C129_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C129_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C129_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C129_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C129_REG_OFFSET 0x1444

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C129_REG_OFFSET 0x1448
#define SCMI_DOORBELL_C129_INTR_BIT 0
#define SCMI_DOORBELL_C129_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C129_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C129_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C129_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C129_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C129_REG_OFFSET 0x144c
#define SCMI_COMPLETION_INTERRUPT_C129_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C129_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C129_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C129_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C129_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C129_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C130_REG_OFFSET 0x1450

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C130_REG_OFFSET 0x1454
#define SCMI_CHANNEL_STATUS_C130_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C130_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C130_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C130_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C130_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C130_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C130_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C130_REG_OFFSET 0x1458

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C130_REG_OFFSET 0x145c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C130_REG_OFFSET 0x1460
#define SCMI_CHANNEL_FLAGS_C130_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C130_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C130_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C130_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C130_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C130_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C130_REG_OFFSET 0x1464

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C130_REG_OFFSET 0x1468
#define SCMI_MESSAGE_HEADER_C130_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C130_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C130_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C130_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C130_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C130_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C130_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C130_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C130_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C130_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C130_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C130_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C130_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C130_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C130_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C130_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C130_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C130_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C130_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C130_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C130_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C130_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C130_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C130_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C130_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C130_REG_OFFSET 0x146c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C130_REG_OFFSET 0x1470
#define SCMI_DOORBELL_C130_INTR_BIT 0
#define SCMI_DOORBELL_C130_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C130_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C130_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C130_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C130_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C130_REG_OFFSET 0x1474
#define SCMI_COMPLETION_INTERRUPT_C130_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C130_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C130_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C130_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C130_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C130_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C131_REG_OFFSET 0x1478

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C131_REG_OFFSET 0x147c
#define SCMI_CHANNEL_STATUS_C131_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C131_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C131_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C131_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C131_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C131_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C131_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C131_REG_OFFSET 0x1480

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C131_REG_OFFSET 0x1484

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C131_REG_OFFSET 0x1488
#define SCMI_CHANNEL_FLAGS_C131_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C131_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C131_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C131_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C131_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C131_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C131_REG_OFFSET 0x148c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C131_REG_OFFSET 0x1490
#define SCMI_MESSAGE_HEADER_C131_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C131_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C131_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C131_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C131_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C131_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C131_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C131_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C131_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C131_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C131_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C131_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C131_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C131_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C131_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C131_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C131_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C131_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C131_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C131_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C131_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C131_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C131_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C131_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C131_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C131_REG_OFFSET 0x1494

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C131_REG_OFFSET 0x1498
#define SCMI_DOORBELL_C131_INTR_BIT 0
#define SCMI_DOORBELL_C131_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C131_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C131_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C131_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C131_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C131_REG_OFFSET 0x149c
#define SCMI_COMPLETION_INTERRUPT_C131_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C131_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C131_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C131_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C131_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C131_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C132_REG_OFFSET 0x14a0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C132_REG_OFFSET 0x14a4
#define SCMI_CHANNEL_STATUS_C132_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C132_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C132_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C132_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C132_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C132_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C132_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C132_REG_OFFSET 0x14a8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C132_REG_OFFSET 0x14ac

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C132_REG_OFFSET 0x14b0
#define SCMI_CHANNEL_FLAGS_C132_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C132_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C132_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C132_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C132_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C132_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C132_REG_OFFSET 0x14b4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C132_REG_OFFSET 0x14b8
#define SCMI_MESSAGE_HEADER_C132_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C132_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C132_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C132_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C132_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C132_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C132_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C132_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C132_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C132_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C132_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C132_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C132_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C132_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C132_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C132_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C132_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C132_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C132_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C132_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C132_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C132_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C132_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C132_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C132_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C132_REG_OFFSET 0x14bc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C132_REG_OFFSET 0x14c0
#define SCMI_DOORBELL_C132_INTR_BIT 0
#define SCMI_DOORBELL_C132_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C132_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C132_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C132_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C132_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C132_REG_OFFSET 0x14c4
#define SCMI_COMPLETION_INTERRUPT_C132_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C132_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C132_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C132_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C132_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C132_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C133_REG_OFFSET 0x14c8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C133_REG_OFFSET 0x14cc
#define SCMI_CHANNEL_STATUS_C133_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C133_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C133_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C133_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C133_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C133_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C133_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C133_REG_OFFSET 0x14d0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C133_REG_OFFSET 0x14d4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C133_REG_OFFSET 0x14d8
#define SCMI_CHANNEL_FLAGS_C133_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C133_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C133_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C133_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C133_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C133_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C133_REG_OFFSET 0x14dc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C133_REG_OFFSET 0x14e0
#define SCMI_MESSAGE_HEADER_C133_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C133_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C133_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C133_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C133_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C133_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C133_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C133_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C133_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C133_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C133_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C133_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C133_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C133_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C133_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C133_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C133_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C133_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C133_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C133_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C133_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C133_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C133_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C133_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C133_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C133_REG_OFFSET 0x14e4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C133_REG_OFFSET 0x14e8
#define SCMI_DOORBELL_C133_INTR_BIT 0
#define SCMI_DOORBELL_C133_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C133_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C133_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C133_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C133_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C133_REG_OFFSET 0x14ec
#define SCMI_COMPLETION_INTERRUPT_C133_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C133_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C133_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C133_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C133_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C133_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C134_REG_OFFSET 0x14f0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C134_REG_OFFSET 0x14f4
#define SCMI_CHANNEL_STATUS_C134_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C134_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C134_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C134_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C134_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C134_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C134_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C134_REG_OFFSET 0x14f8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C134_REG_OFFSET 0x14fc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C134_REG_OFFSET 0x1500
#define SCMI_CHANNEL_FLAGS_C134_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C134_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C134_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C134_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C134_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C134_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C134_REG_OFFSET 0x1504

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C134_REG_OFFSET 0x1508
#define SCMI_MESSAGE_HEADER_C134_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C134_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C134_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C134_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C134_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C134_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C134_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C134_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C134_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C134_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C134_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C134_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C134_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C134_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C134_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C134_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C134_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C134_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C134_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C134_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C134_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C134_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C134_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C134_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C134_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C134_REG_OFFSET 0x150c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C134_REG_OFFSET 0x1510
#define SCMI_DOORBELL_C134_INTR_BIT 0
#define SCMI_DOORBELL_C134_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C134_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C134_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C134_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C134_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C134_REG_OFFSET 0x1514
#define SCMI_COMPLETION_INTERRUPT_C134_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C134_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C134_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C134_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C134_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C134_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C135_REG_OFFSET 0x1518

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C135_REG_OFFSET 0x151c
#define SCMI_CHANNEL_STATUS_C135_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C135_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C135_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C135_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C135_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C135_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C135_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C135_REG_OFFSET 0x1520

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C135_REG_OFFSET 0x1524

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C135_REG_OFFSET 0x1528
#define SCMI_CHANNEL_FLAGS_C135_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C135_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C135_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C135_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C135_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C135_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C135_REG_OFFSET 0x152c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C135_REG_OFFSET 0x1530
#define SCMI_MESSAGE_HEADER_C135_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C135_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C135_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C135_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C135_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C135_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C135_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C135_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C135_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C135_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C135_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C135_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C135_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C135_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C135_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C135_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C135_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C135_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C135_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C135_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C135_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C135_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C135_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C135_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C135_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C135_REG_OFFSET 0x1534

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C135_REG_OFFSET 0x1538
#define SCMI_DOORBELL_C135_INTR_BIT 0
#define SCMI_DOORBELL_C135_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C135_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C135_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C135_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C135_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C135_REG_OFFSET 0x153c
#define SCMI_COMPLETION_INTERRUPT_C135_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C135_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C135_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C135_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C135_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C135_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C136_REG_OFFSET 0x1540

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C136_REG_OFFSET 0x1544
#define SCMI_CHANNEL_STATUS_C136_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C136_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C136_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C136_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C136_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C136_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C136_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C136_REG_OFFSET 0x1548

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C136_REG_OFFSET 0x154c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C136_REG_OFFSET 0x1550
#define SCMI_CHANNEL_FLAGS_C136_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C136_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C136_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C136_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C136_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C136_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C136_REG_OFFSET 0x1554

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C136_REG_OFFSET 0x1558
#define SCMI_MESSAGE_HEADER_C136_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C136_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C136_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C136_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C136_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C136_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C136_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C136_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C136_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C136_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C136_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C136_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C136_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C136_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C136_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C136_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C136_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C136_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C136_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C136_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C136_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C136_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C136_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C136_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C136_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C136_REG_OFFSET 0x155c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C136_REG_OFFSET 0x1560
#define SCMI_DOORBELL_C136_INTR_BIT 0
#define SCMI_DOORBELL_C136_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C136_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C136_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C136_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C136_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C136_REG_OFFSET 0x1564
#define SCMI_COMPLETION_INTERRUPT_C136_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C136_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C136_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C136_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C136_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C136_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C137_REG_OFFSET 0x1568

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C137_REG_OFFSET 0x156c
#define SCMI_CHANNEL_STATUS_C137_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C137_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C137_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C137_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C137_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C137_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C137_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C137_REG_OFFSET 0x1570

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C137_REG_OFFSET 0x1574

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C137_REG_OFFSET 0x1578
#define SCMI_CHANNEL_FLAGS_C137_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C137_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C137_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C137_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C137_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C137_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C137_REG_OFFSET 0x157c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C137_REG_OFFSET 0x1580
#define SCMI_MESSAGE_HEADER_C137_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C137_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C137_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C137_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C137_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C137_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C137_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C137_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C137_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C137_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C137_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C137_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C137_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C137_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C137_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C137_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C137_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C137_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C137_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C137_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C137_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C137_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C137_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C137_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C137_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C137_REG_OFFSET 0x1584

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C137_REG_OFFSET 0x1588
#define SCMI_DOORBELL_C137_INTR_BIT 0
#define SCMI_DOORBELL_C137_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C137_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C137_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C137_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C137_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C137_REG_OFFSET 0x158c
#define SCMI_COMPLETION_INTERRUPT_C137_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C137_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C137_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C137_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C137_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C137_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C138_REG_OFFSET 0x1590

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C138_REG_OFFSET 0x1594
#define SCMI_CHANNEL_STATUS_C138_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C138_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C138_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C138_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C138_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C138_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C138_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C138_REG_OFFSET 0x1598

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C138_REG_OFFSET 0x159c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C138_REG_OFFSET 0x15a0
#define SCMI_CHANNEL_FLAGS_C138_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C138_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C138_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C138_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C138_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C138_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C138_REG_OFFSET 0x15a4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C138_REG_OFFSET 0x15a8
#define SCMI_MESSAGE_HEADER_C138_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C138_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C138_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C138_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C138_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C138_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C138_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C138_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C138_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C138_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C138_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C138_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C138_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C138_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C138_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C138_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C138_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C138_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C138_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C138_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C138_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C138_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C138_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C138_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C138_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C138_REG_OFFSET 0x15ac

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C138_REG_OFFSET 0x15b0
#define SCMI_DOORBELL_C138_INTR_BIT 0
#define SCMI_DOORBELL_C138_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C138_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C138_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C138_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C138_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C138_REG_OFFSET 0x15b4
#define SCMI_COMPLETION_INTERRUPT_C138_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C138_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C138_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C138_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C138_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C138_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C139_REG_OFFSET 0x15b8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C139_REG_OFFSET 0x15bc
#define SCMI_CHANNEL_STATUS_C139_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C139_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C139_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C139_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C139_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C139_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C139_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C139_REG_OFFSET 0x15c0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C139_REG_OFFSET 0x15c4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C139_REG_OFFSET 0x15c8
#define SCMI_CHANNEL_FLAGS_C139_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C139_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C139_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C139_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C139_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C139_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C139_REG_OFFSET 0x15cc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C139_REG_OFFSET 0x15d0
#define SCMI_MESSAGE_HEADER_C139_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C139_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C139_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C139_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C139_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C139_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C139_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C139_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C139_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C139_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C139_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C139_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C139_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C139_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C139_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C139_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C139_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C139_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C139_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C139_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C139_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C139_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C139_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C139_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C139_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C139_REG_OFFSET 0x15d4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C139_REG_OFFSET 0x15d8
#define SCMI_DOORBELL_C139_INTR_BIT 0
#define SCMI_DOORBELL_C139_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C139_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C139_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C139_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C139_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C139_REG_OFFSET 0x15dc
#define SCMI_COMPLETION_INTERRUPT_C139_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C139_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C139_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C139_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C139_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C139_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C140_REG_OFFSET 0x15e0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C140_REG_OFFSET 0x15e4
#define SCMI_CHANNEL_STATUS_C140_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C140_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C140_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C140_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C140_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C140_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C140_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C140_REG_OFFSET 0x15e8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C140_REG_OFFSET 0x15ec

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C140_REG_OFFSET 0x15f0
#define SCMI_CHANNEL_FLAGS_C140_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C140_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C140_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C140_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C140_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C140_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C140_REG_OFFSET 0x15f4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C140_REG_OFFSET 0x15f8
#define SCMI_MESSAGE_HEADER_C140_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C140_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C140_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C140_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C140_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C140_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C140_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C140_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C140_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C140_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C140_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C140_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C140_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C140_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C140_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C140_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C140_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C140_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C140_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C140_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C140_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C140_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C140_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C140_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C140_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C140_REG_OFFSET 0x15fc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C140_REG_OFFSET 0x1600
#define SCMI_DOORBELL_C140_INTR_BIT 0
#define SCMI_DOORBELL_C140_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C140_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C140_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C140_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C140_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C140_REG_OFFSET 0x1604
#define SCMI_COMPLETION_INTERRUPT_C140_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C140_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C140_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C140_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C140_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C140_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C141_REG_OFFSET 0x1608

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C141_REG_OFFSET 0x160c
#define SCMI_CHANNEL_STATUS_C141_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C141_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C141_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C141_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C141_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C141_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C141_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C141_REG_OFFSET 0x1610

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C141_REG_OFFSET 0x1614

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C141_REG_OFFSET 0x1618
#define SCMI_CHANNEL_FLAGS_C141_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C141_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C141_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C141_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C141_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C141_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C141_REG_OFFSET 0x161c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C141_REG_OFFSET 0x1620
#define SCMI_MESSAGE_HEADER_C141_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C141_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C141_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C141_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C141_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C141_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C141_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C141_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C141_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C141_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C141_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C141_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C141_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C141_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C141_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C141_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C141_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C141_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C141_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C141_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C141_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C141_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C141_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C141_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C141_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C141_REG_OFFSET 0x1624

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C141_REG_OFFSET 0x1628
#define SCMI_DOORBELL_C141_INTR_BIT 0
#define SCMI_DOORBELL_C141_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C141_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C141_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C141_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C141_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C141_REG_OFFSET 0x162c
#define SCMI_COMPLETION_INTERRUPT_C141_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C141_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C141_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C141_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C141_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C141_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C142_REG_OFFSET 0x1630

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C142_REG_OFFSET 0x1634
#define SCMI_CHANNEL_STATUS_C142_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C142_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C142_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C142_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C142_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C142_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C142_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C142_REG_OFFSET 0x1638

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C142_REG_OFFSET 0x163c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C142_REG_OFFSET 0x1640
#define SCMI_CHANNEL_FLAGS_C142_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C142_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C142_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C142_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C142_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C142_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C142_REG_OFFSET 0x1644

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C142_REG_OFFSET 0x1648
#define SCMI_MESSAGE_HEADER_C142_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C142_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C142_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C142_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C142_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C142_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C142_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C142_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C142_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C142_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C142_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C142_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C142_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C142_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C142_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C142_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C142_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C142_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C142_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C142_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C142_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C142_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C142_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C142_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C142_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C142_REG_OFFSET 0x164c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C142_REG_OFFSET 0x1650
#define SCMI_DOORBELL_C142_INTR_BIT 0
#define SCMI_DOORBELL_C142_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C142_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C142_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C142_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C142_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C142_REG_OFFSET 0x1654
#define SCMI_COMPLETION_INTERRUPT_C142_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C142_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C142_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C142_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C142_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C142_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C143_REG_OFFSET 0x1658

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C143_REG_OFFSET 0x165c
#define SCMI_CHANNEL_STATUS_C143_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C143_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C143_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C143_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C143_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C143_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C143_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C143_REG_OFFSET 0x1660

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C143_REG_OFFSET 0x1664

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C143_REG_OFFSET 0x1668
#define SCMI_CHANNEL_FLAGS_C143_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C143_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C143_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C143_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C143_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C143_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C143_REG_OFFSET 0x166c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C143_REG_OFFSET 0x1670
#define SCMI_MESSAGE_HEADER_C143_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C143_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C143_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C143_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C143_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C143_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C143_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C143_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C143_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C143_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C143_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C143_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C143_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C143_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C143_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C143_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C143_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C143_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C143_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C143_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C143_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C143_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C143_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C143_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C143_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C143_REG_OFFSET 0x1674

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C143_REG_OFFSET 0x1678
#define SCMI_DOORBELL_C143_INTR_BIT 0
#define SCMI_DOORBELL_C143_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C143_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C143_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C143_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C143_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C143_REG_OFFSET 0x167c
#define SCMI_COMPLETION_INTERRUPT_C143_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C143_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C143_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C143_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C143_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C143_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C144_REG_OFFSET 0x1680

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C144_REG_OFFSET 0x1684
#define SCMI_CHANNEL_STATUS_C144_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C144_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C144_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C144_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C144_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C144_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C144_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C144_REG_OFFSET 0x1688

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C144_REG_OFFSET 0x168c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C144_REG_OFFSET 0x1690
#define SCMI_CHANNEL_FLAGS_C144_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C144_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C144_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C144_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C144_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C144_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C144_REG_OFFSET 0x1694

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C144_REG_OFFSET 0x1698
#define SCMI_MESSAGE_HEADER_C144_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C144_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C144_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C144_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C144_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C144_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C144_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C144_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C144_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C144_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C144_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C144_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C144_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C144_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C144_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C144_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C144_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C144_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C144_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C144_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C144_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C144_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C144_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C144_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C144_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C144_REG_OFFSET 0x169c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C144_REG_OFFSET 0x16a0
#define SCMI_DOORBELL_C144_INTR_BIT 0
#define SCMI_DOORBELL_C144_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C144_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C144_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C144_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C144_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C144_REG_OFFSET 0x16a4
#define SCMI_COMPLETION_INTERRUPT_C144_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C144_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C144_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C144_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C144_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C144_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C145_REG_OFFSET 0x16a8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C145_REG_OFFSET 0x16ac
#define SCMI_CHANNEL_STATUS_C145_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C145_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C145_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C145_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C145_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C145_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C145_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C145_REG_OFFSET 0x16b0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C145_REG_OFFSET 0x16b4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C145_REG_OFFSET 0x16b8
#define SCMI_CHANNEL_FLAGS_C145_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C145_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C145_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C145_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C145_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C145_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C145_REG_OFFSET 0x16bc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C145_REG_OFFSET 0x16c0
#define SCMI_MESSAGE_HEADER_C145_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C145_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C145_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C145_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C145_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C145_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C145_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C145_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C145_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C145_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C145_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C145_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C145_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C145_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C145_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C145_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C145_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C145_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C145_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C145_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C145_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C145_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C145_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C145_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C145_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C145_REG_OFFSET 0x16c4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C145_REG_OFFSET 0x16c8
#define SCMI_DOORBELL_C145_INTR_BIT 0
#define SCMI_DOORBELL_C145_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C145_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C145_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C145_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C145_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C145_REG_OFFSET 0x16cc
#define SCMI_COMPLETION_INTERRUPT_C145_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C145_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C145_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C145_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C145_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C145_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C146_REG_OFFSET 0x16d0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C146_REG_OFFSET 0x16d4
#define SCMI_CHANNEL_STATUS_C146_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C146_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C146_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C146_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C146_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C146_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C146_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C146_REG_OFFSET 0x16d8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C146_REG_OFFSET 0x16dc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C146_REG_OFFSET 0x16e0
#define SCMI_CHANNEL_FLAGS_C146_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C146_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C146_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C146_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C146_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C146_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C146_REG_OFFSET 0x16e4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C146_REG_OFFSET 0x16e8
#define SCMI_MESSAGE_HEADER_C146_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C146_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C146_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C146_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C146_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C146_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C146_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C146_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C146_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C146_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C146_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C146_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C146_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C146_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C146_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C146_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C146_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C146_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C146_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C146_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C146_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C146_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C146_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C146_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C146_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C146_REG_OFFSET 0x16ec

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C146_REG_OFFSET 0x16f0
#define SCMI_DOORBELL_C146_INTR_BIT 0
#define SCMI_DOORBELL_C146_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C146_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C146_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C146_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C146_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C146_REG_OFFSET 0x16f4
#define SCMI_COMPLETION_INTERRUPT_C146_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C146_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C146_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C146_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C146_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C146_PRESERVE_MASK_OFFSET })

#ifdef __cplusplus
}  // extern "C"
#endif
#endif  // _SCMI_REG_DEFS_
// End generated register defines for scmi