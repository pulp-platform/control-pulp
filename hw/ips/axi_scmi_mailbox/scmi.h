// Generated register defines for scmi

// Copyright information found in source file:
// Copyright lowRISC contributors.

// Licensing information found in source file:
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

#ifndef _SCMI_REG_DEFS_
#define _SCMI_REG_DEFS_

#ifdef __cplusplus
extern "C" {
#endif
// Register width
#define SCMI_PARAM_REG_WIDTH 32

// Reserved, must be 0
#define SCMI_RESERVED_1_C0_REG_OFFSET 0x0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C0_REG_OFFSET 0x4
#define SCMI_CHANNEL_STATUS_C0_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C0_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C0_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C0_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C0_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C0_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C0_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C0_REG_OFFSET 0x8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C0_REG_OFFSET 0xc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C0_REG_OFFSET 0x10
#define SCMI_CHANNEL_FLAGS_C0_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C0_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C0_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C0_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C0_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C0_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C0_REG_OFFSET 0x14

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C0_REG_OFFSET 0x18
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C0_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C0_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C0_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C0_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C0_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C0_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C0_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C0_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C0_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C0_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C0_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C0_REG_OFFSET 0x1c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C0_REG_OFFSET 0x20
#define SCMI_DOORBELL_C0_INTR_BIT 0
#define SCMI_DOORBELL_C0_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C0_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C0_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C0_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C0_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C0_REG_OFFSET 0x24
#define SCMI_COMPLETION_INTERRUPT_C0_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C0_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C1_REG_OFFSET 0x28

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C1_REG_OFFSET 0x2c
#define SCMI_CHANNEL_STATUS_C1_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C1_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C1_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C1_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C1_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C1_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C1_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C1_REG_OFFSET 0x30

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C1_REG_OFFSET 0x34

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C1_REG_OFFSET 0x38
#define SCMI_CHANNEL_FLAGS_C1_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C1_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C1_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C1_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C1_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C1_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C1_REG_OFFSET 0x3c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C1_REG_OFFSET 0x40
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C1_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C1_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C1_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C1_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C1_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C1_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C1_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C1_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C1_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C1_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C1_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C1_REG_OFFSET 0x44

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C1_REG_OFFSET 0x48
#define SCMI_DOORBELL_C1_INTR_BIT 0
#define SCMI_DOORBELL_C1_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C1_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C1_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C1_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C1_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C1_REG_OFFSET 0x4c
#define SCMI_COMPLETION_INTERRUPT_C1_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C1_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C2_REG_OFFSET 0x50

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C2_REG_OFFSET 0x54
#define SCMI_CHANNEL_STATUS_C2_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C2_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C2_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C2_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C2_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C2_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C2_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C2_REG_OFFSET 0x58

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C2_REG_OFFSET 0x5c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C2_REG_OFFSET 0x60
#define SCMI_CHANNEL_FLAGS_C2_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C2_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C2_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C2_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C2_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C2_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C2_REG_OFFSET 0x64

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C2_REG_OFFSET 0x68
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C2_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C2_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C2_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C2_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C2_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C2_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C2_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C2_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C2_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C2_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C2_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C2_REG_OFFSET 0x6c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C2_REG_OFFSET 0x70
#define SCMI_DOORBELL_C2_INTR_BIT 0
#define SCMI_DOORBELL_C2_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C2_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C2_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C2_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C2_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C2_REG_OFFSET 0x74
#define SCMI_COMPLETION_INTERRUPT_C2_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C2_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C3_REG_OFFSET 0x78

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C3_REG_OFFSET 0x7c
#define SCMI_CHANNEL_STATUS_C3_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C3_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C3_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C3_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C3_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C3_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C3_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C3_REG_OFFSET 0x80

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C3_REG_OFFSET 0x84

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C3_REG_OFFSET 0x88
#define SCMI_CHANNEL_FLAGS_C3_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C3_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C3_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C3_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C3_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C3_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C3_REG_OFFSET 0x8c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C3_REG_OFFSET 0x90
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C3_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C3_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C3_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C3_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C3_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C3_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C3_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C3_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C3_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C3_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C3_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C3_REG_OFFSET 0x94

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C3_REG_OFFSET 0x98
#define SCMI_DOORBELL_C3_INTR_BIT 0
#define SCMI_DOORBELL_C3_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C3_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C3_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C3_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C3_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C3_REG_OFFSET 0x9c
#define SCMI_COMPLETION_INTERRUPT_C3_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C3_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C4_REG_OFFSET 0xa0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C4_REG_OFFSET 0xa4
#define SCMI_CHANNEL_STATUS_C4_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C4_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C4_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C4_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C4_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C4_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C4_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C4_REG_OFFSET 0xa8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C4_REG_OFFSET 0xac

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C4_REG_OFFSET 0xb0
#define SCMI_CHANNEL_FLAGS_C4_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C4_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C4_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C4_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C4_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C4_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C4_REG_OFFSET 0xb4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C4_REG_OFFSET 0xb8
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C4_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C4_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C4_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C4_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C4_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C4_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C4_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C4_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C4_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C4_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C4_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C4_REG_OFFSET 0xbc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C4_REG_OFFSET 0xc0
#define SCMI_DOORBELL_C4_INTR_BIT 0
#define SCMI_DOORBELL_C4_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C4_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C4_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C4_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C4_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C4_REG_OFFSET 0xc4
#define SCMI_COMPLETION_INTERRUPT_C4_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C4_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C5_REG_OFFSET 0xc8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C5_REG_OFFSET 0xcc
#define SCMI_CHANNEL_STATUS_C5_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C5_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C5_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C5_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C5_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C5_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C5_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C5_REG_OFFSET 0xd0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C5_REG_OFFSET 0xd4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C5_REG_OFFSET 0xd8
#define SCMI_CHANNEL_FLAGS_C5_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C5_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C5_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C5_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C5_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C5_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C5_REG_OFFSET 0xdc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C5_REG_OFFSET 0xe0
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C5_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C5_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C5_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C5_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C5_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C5_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C5_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C5_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C5_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C5_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C5_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C5_REG_OFFSET 0xe4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C5_REG_OFFSET 0xe8
#define SCMI_DOORBELL_C5_INTR_BIT 0
#define SCMI_DOORBELL_C5_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C5_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C5_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C5_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C5_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C5_REG_OFFSET 0xec
#define SCMI_COMPLETION_INTERRUPT_C5_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C5_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C6_REG_OFFSET 0xf0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C6_REG_OFFSET 0xf4
#define SCMI_CHANNEL_STATUS_C6_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C6_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C6_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C6_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C6_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C6_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C6_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C6_REG_OFFSET 0xf8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C6_REG_OFFSET 0xfc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C6_REG_OFFSET 0x100
#define SCMI_CHANNEL_FLAGS_C6_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C6_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C6_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C6_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C6_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C6_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C6_REG_OFFSET 0x104

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C6_REG_OFFSET 0x108
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C6_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C6_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C6_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C6_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C6_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C6_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C6_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C6_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C6_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C6_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C6_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C6_REG_OFFSET 0x10c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C6_REG_OFFSET 0x110
#define SCMI_DOORBELL_C6_INTR_BIT 0
#define SCMI_DOORBELL_C6_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C6_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C6_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C6_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C6_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C6_REG_OFFSET 0x114
#define SCMI_COMPLETION_INTERRUPT_C6_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C6_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C7_REG_OFFSET 0x118

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C7_REG_OFFSET 0x11c
#define SCMI_CHANNEL_STATUS_C7_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C7_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C7_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C7_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C7_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C7_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C7_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C7_REG_OFFSET 0x120

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C7_REG_OFFSET 0x124

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C7_REG_OFFSET 0x128
#define SCMI_CHANNEL_FLAGS_C7_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C7_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C7_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C7_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C7_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C7_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C7_REG_OFFSET 0x12c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C7_REG_OFFSET 0x130
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C7_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C7_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C7_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C7_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C7_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C7_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C7_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C7_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C7_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C7_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C7_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C7_REG_OFFSET 0x134

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C7_REG_OFFSET 0x138
#define SCMI_DOORBELL_C7_INTR_BIT 0
#define SCMI_DOORBELL_C7_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C7_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C7_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C7_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C7_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C7_REG_OFFSET 0x13c
#define SCMI_COMPLETION_INTERRUPT_C7_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C7_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C8_REG_OFFSET 0x140

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C8_REG_OFFSET 0x144
#define SCMI_CHANNEL_STATUS_C8_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C8_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C8_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C8_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C8_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C8_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C8_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C8_REG_OFFSET 0x148

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C8_REG_OFFSET 0x14c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C8_REG_OFFSET 0x150
#define SCMI_CHANNEL_FLAGS_C8_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C8_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C8_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C8_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C8_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C8_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C8_REG_OFFSET 0x154

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C8_REG_OFFSET 0x158
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C8_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C8_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C8_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C8_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C8_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C8_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C8_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C8_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C8_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C8_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C8_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C8_REG_OFFSET 0x15c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C8_REG_OFFSET 0x160
#define SCMI_DOORBELL_C8_INTR_BIT 0
#define SCMI_DOORBELL_C8_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C8_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C8_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C8_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C8_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C8_REG_OFFSET 0x164
#define SCMI_COMPLETION_INTERRUPT_C8_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C8_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C9_REG_OFFSET 0x168

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C9_REG_OFFSET 0x16c
#define SCMI_CHANNEL_STATUS_C9_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C9_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C9_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C9_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C9_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C9_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C9_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C9_REG_OFFSET 0x170

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C9_REG_OFFSET 0x174

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C9_REG_OFFSET 0x178
#define SCMI_CHANNEL_FLAGS_C9_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C9_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C9_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C9_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C9_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C9_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C9_REG_OFFSET 0x17c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C9_REG_OFFSET 0x180
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C9_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C9_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C9_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C9_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C9_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C9_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C9_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C9_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C9_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C9_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C9_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C9_REG_OFFSET 0x184

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C9_REG_OFFSET 0x188
#define SCMI_DOORBELL_C9_INTR_BIT 0
#define SCMI_DOORBELL_C9_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C9_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C9_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C9_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C9_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C9_REG_OFFSET 0x18c
#define SCMI_COMPLETION_INTERRUPT_C9_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C9_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C10_REG_OFFSET 0x190

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C10_REG_OFFSET 0x194
#define SCMI_CHANNEL_STATUS_C10_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C10_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C10_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C10_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C10_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C10_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C10_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C10_REG_OFFSET 0x198

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C10_REG_OFFSET 0x19c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C10_REG_OFFSET 0x1a0
#define SCMI_CHANNEL_FLAGS_C10_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C10_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C10_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C10_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C10_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C10_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C10_REG_OFFSET 0x1a4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C10_REG_OFFSET 0x1a8
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C10_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C10_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C10_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C10_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C10_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C10_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C10_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C10_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C10_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C10_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C10_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C10_REG_OFFSET 0x1ac

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C10_REG_OFFSET 0x1b0
#define SCMI_DOORBELL_C10_INTR_BIT 0
#define SCMI_DOORBELL_C10_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C10_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C10_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C10_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C10_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C10_REG_OFFSET 0x1b4
#define SCMI_COMPLETION_INTERRUPT_C10_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C10_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C11_REG_OFFSET 0x1b8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C11_REG_OFFSET 0x1bc
#define SCMI_CHANNEL_STATUS_C11_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C11_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C11_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C11_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C11_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C11_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C11_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C11_REG_OFFSET 0x1c0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C11_REG_OFFSET 0x1c4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C11_REG_OFFSET 0x1c8
#define SCMI_CHANNEL_FLAGS_C11_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C11_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C11_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C11_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C11_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C11_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C11_REG_OFFSET 0x1cc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C11_REG_OFFSET 0x1d0
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C11_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C11_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C11_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C11_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C11_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C11_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C11_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C11_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C11_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C11_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C11_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C11_REG_OFFSET 0x1d4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C11_REG_OFFSET 0x1d8
#define SCMI_DOORBELL_C11_INTR_BIT 0
#define SCMI_DOORBELL_C11_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C11_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C11_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C11_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C11_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C11_REG_OFFSET 0x1dc
#define SCMI_COMPLETION_INTERRUPT_C11_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C11_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C12_REG_OFFSET 0x1e0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C12_REG_OFFSET 0x1e4
#define SCMI_CHANNEL_STATUS_C12_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C12_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C12_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C12_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C12_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C12_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C12_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C12_REG_OFFSET 0x1e8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C12_REG_OFFSET 0x1ec

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C12_REG_OFFSET 0x1f0
#define SCMI_CHANNEL_FLAGS_C12_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C12_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C12_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C12_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C12_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C12_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C12_REG_OFFSET 0x1f4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C12_REG_OFFSET 0x1f8
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C12_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C12_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C12_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C12_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C12_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C12_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C12_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C12_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C12_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C12_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C12_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C12_REG_OFFSET 0x1fc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C12_REG_OFFSET 0x200
#define SCMI_DOORBELL_C12_INTR_BIT 0
#define SCMI_DOORBELL_C12_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C12_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C12_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C12_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C12_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C12_REG_OFFSET 0x204
#define SCMI_COMPLETION_INTERRUPT_C12_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C12_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C13_REG_OFFSET 0x208

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C13_REG_OFFSET 0x20c
#define SCMI_CHANNEL_STATUS_C13_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C13_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C13_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C13_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C13_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C13_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C13_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C13_REG_OFFSET 0x210

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C13_REG_OFFSET 0x214

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C13_REG_OFFSET 0x218
#define SCMI_CHANNEL_FLAGS_C13_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C13_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C13_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C13_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C13_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C13_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C13_REG_OFFSET 0x21c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C13_REG_OFFSET 0x220
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C13_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C13_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C13_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C13_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C13_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C13_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C13_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C13_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C13_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C13_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C13_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C13_REG_OFFSET 0x224

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C13_REG_OFFSET 0x228
#define SCMI_DOORBELL_C13_INTR_BIT 0
#define SCMI_DOORBELL_C13_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C13_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C13_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C13_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C13_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C13_REG_OFFSET 0x22c
#define SCMI_COMPLETION_INTERRUPT_C13_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C13_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C14_REG_OFFSET 0x230

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C14_REG_OFFSET 0x234
#define SCMI_CHANNEL_STATUS_C14_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C14_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C14_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C14_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C14_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C14_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C14_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C14_REG_OFFSET 0x238

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C14_REG_OFFSET 0x23c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C14_REG_OFFSET 0x240
#define SCMI_CHANNEL_FLAGS_C14_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C14_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C14_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C14_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C14_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C14_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C14_REG_OFFSET 0x244

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C14_REG_OFFSET 0x248
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C14_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C14_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C14_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C14_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C14_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C14_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C14_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C14_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C14_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C14_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C14_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C14_REG_OFFSET 0x24c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C14_REG_OFFSET 0x250
#define SCMI_DOORBELL_C14_INTR_BIT 0
#define SCMI_DOORBELL_C14_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C14_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C14_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C14_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C14_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C14_REG_OFFSET 0x254
#define SCMI_COMPLETION_INTERRUPT_C14_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C14_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C15_REG_OFFSET 0x258

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C15_REG_OFFSET 0x25c
#define SCMI_CHANNEL_STATUS_C15_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C15_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C15_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C15_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C15_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C15_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C15_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C15_REG_OFFSET 0x260

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C15_REG_OFFSET 0x264

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C15_REG_OFFSET 0x268
#define SCMI_CHANNEL_FLAGS_C15_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C15_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C15_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C15_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C15_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C15_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C15_REG_OFFSET 0x26c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C15_REG_OFFSET 0x270
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C15_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C15_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C15_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C15_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C15_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C15_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C15_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C15_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C15_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C15_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C15_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C15_REG_OFFSET 0x274

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C15_REG_OFFSET 0x278
#define SCMI_DOORBELL_C15_INTR_BIT 0
#define SCMI_DOORBELL_C15_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C15_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C15_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C15_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C15_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C15_REG_OFFSET 0x27c
#define SCMI_COMPLETION_INTERRUPT_C15_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C15_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C16_REG_OFFSET 0x280

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C16_REG_OFFSET 0x284
#define SCMI_CHANNEL_STATUS_C16_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C16_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C16_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C16_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C16_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C16_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C16_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C16_REG_OFFSET 0x288

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C16_REG_OFFSET 0x28c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C16_REG_OFFSET 0x290
#define SCMI_CHANNEL_FLAGS_C16_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C16_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C16_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C16_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C16_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C16_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C16_REG_OFFSET 0x294

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C16_REG_OFFSET 0x298
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C16_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C16_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C16_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C16_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C16_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C16_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C16_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C16_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C16_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C16_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C16_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C16_REG_OFFSET 0x29c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C16_REG_OFFSET 0x2a0
#define SCMI_DOORBELL_C16_INTR_BIT 0
#define SCMI_DOORBELL_C16_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C16_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C16_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C16_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C16_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C16_REG_OFFSET 0x2a4
#define SCMI_COMPLETION_INTERRUPT_C16_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C16_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C17_REG_OFFSET 0x2a8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C17_REG_OFFSET 0x2ac
#define SCMI_CHANNEL_STATUS_C17_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C17_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C17_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C17_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C17_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C17_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C17_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C17_REG_OFFSET 0x2b0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C17_REG_OFFSET 0x2b4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C17_REG_OFFSET 0x2b8
#define SCMI_CHANNEL_FLAGS_C17_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C17_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C17_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C17_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C17_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C17_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C17_REG_OFFSET 0x2bc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C17_REG_OFFSET 0x2c0
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C17_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C17_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C17_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C17_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C17_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C17_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C17_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C17_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C17_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C17_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C17_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C17_REG_OFFSET 0x2c4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C17_REG_OFFSET 0x2c8
#define SCMI_DOORBELL_C17_INTR_BIT 0
#define SCMI_DOORBELL_C17_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C17_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C17_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C17_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C17_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C17_REG_OFFSET 0x2cc
#define SCMI_COMPLETION_INTERRUPT_C17_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C17_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C18_REG_OFFSET 0x2d0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C18_REG_OFFSET 0x2d4
#define SCMI_CHANNEL_STATUS_C18_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C18_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C18_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C18_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C18_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C18_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C18_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C18_REG_OFFSET 0x2d8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C18_REG_OFFSET 0x2dc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C18_REG_OFFSET 0x2e0
#define SCMI_CHANNEL_FLAGS_C18_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C18_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C18_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C18_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C18_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C18_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C18_REG_OFFSET 0x2e4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C18_REG_OFFSET 0x2e8
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C18_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C18_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C18_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C18_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C18_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C18_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C18_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C18_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C18_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C18_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C18_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C18_REG_OFFSET 0x2ec

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C18_REG_OFFSET 0x2f0
#define SCMI_DOORBELL_C18_INTR_BIT 0
#define SCMI_DOORBELL_C18_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C18_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C18_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C18_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C18_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C18_REG_OFFSET 0x2f4
#define SCMI_COMPLETION_INTERRUPT_C18_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C18_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C19_REG_OFFSET 0x2f8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C19_REG_OFFSET 0x2fc
#define SCMI_CHANNEL_STATUS_C19_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C19_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C19_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C19_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C19_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C19_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C19_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C19_REG_OFFSET 0x300

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C19_REG_OFFSET 0x304

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C19_REG_OFFSET 0x308
#define SCMI_CHANNEL_FLAGS_C19_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C19_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C19_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C19_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C19_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C19_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C19_REG_OFFSET 0x30c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C19_REG_OFFSET 0x310
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C19_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C19_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C19_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C19_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C19_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C19_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C19_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C19_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C19_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C19_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C19_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C19_REG_OFFSET 0x314

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C19_REG_OFFSET 0x318
#define SCMI_DOORBELL_C19_INTR_BIT 0
#define SCMI_DOORBELL_C19_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C19_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C19_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C19_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C19_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C19_REG_OFFSET 0x31c
#define SCMI_COMPLETION_INTERRUPT_C19_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C19_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C20_REG_OFFSET 0x320

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C20_REG_OFFSET 0x324
#define SCMI_CHANNEL_STATUS_C20_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C20_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C20_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C20_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C20_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C20_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C20_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C20_REG_OFFSET 0x328

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C20_REG_OFFSET 0x32c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C20_REG_OFFSET 0x330
#define SCMI_CHANNEL_FLAGS_C20_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C20_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C20_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C20_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C20_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C20_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C20_REG_OFFSET 0x334

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C20_REG_OFFSET 0x338
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C20_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C20_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C20_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C20_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C20_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C20_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C20_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C20_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C20_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C20_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C20_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C20_REG_OFFSET 0x33c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C20_REG_OFFSET 0x340
#define SCMI_DOORBELL_C20_INTR_BIT 0
#define SCMI_DOORBELL_C20_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C20_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C20_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C20_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C20_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C20_REG_OFFSET 0x344
#define SCMI_COMPLETION_INTERRUPT_C20_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C20_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C21_REG_OFFSET 0x348

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C21_REG_OFFSET 0x34c
#define SCMI_CHANNEL_STATUS_C21_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C21_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C21_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C21_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C21_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C21_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C21_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C21_REG_OFFSET 0x350

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C21_REG_OFFSET 0x354

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C21_REG_OFFSET 0x358
#define SCMI_CHANNEL_FLAGS_C21_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C21_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C21_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C21_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C21_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C21_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C21_REG_OFFSET 0x35c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C21_REG_OFFSET 0x360
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C21_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C21_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C21_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C21_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C21_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C21_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C21_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C21_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C21_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C21_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C21_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C21_REG_OFFSET 0x364

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C21_REG_OFFSET 0x368
#define SCMI_DOORBELL_C21_INTR_BIT 0
#define SCMI_DOORBELL_C21_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C21_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C21_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C21_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C21_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C21_REG_OFFSET 0x36c
#define SCMI_COMPLETION_INTERRUPT_C21_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C21_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C22_REG_OFFSET 0x370

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C22_REG_OFFSET 0x374
#define SCMI_CHANNEL_STATUS_C22_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C22_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C22_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C22_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C22_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C22_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C22_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C22_REG_OFFSET 0x378

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C22_REG_OFFSET 0x37c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C22_REG_OFFSET 0x380
#define SCMI_CHANNEL_FLAGS_C22_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C22_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C22_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C22_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C22_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C22_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C22_REG_OFFSET 0x384

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C22_REG_OFFSET 0x388
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C22_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C22_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C22_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C22_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C22_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C22_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C22_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C22_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C22_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C22_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C22_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C22_REG_OFFSET 0x38c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C22_REG_OFFSET 0x390
#define SCMI_DOORBELL_C22_INTR_BIT 0
#define SCMI_DOORBELL_C22_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C22_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C22_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C22_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C22_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C22_REG_OFFSET 0x394
#define SCMI_COMPLETION_INTERRUPT_C22_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C22_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C23_REG_OFFSET 0x398

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C23_REG_OFFSET 0x39c
#define SCMI_CHANNEL_STATUS_C23_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C23_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C23_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C23_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C23_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C23_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C23_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C23_REG_OFFSET 0x3a0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C23_REG_OFFSET 0x3a4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C23_REG_OFFSET 0x3a8
#define SCMI_CHANNEL_FLAGS_C23_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C23_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C23_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C23_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C23_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C23_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C23_REG_OFFSET 0x3ac

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C23_REG_OFFSET 0x3b0
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C23_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C23_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C23_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C23_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C23_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C23_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C23_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C23_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C23_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C23_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C23_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C23_REG_OFFSET 0x3b4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C23_REG_OFFSET 0x3b8
#define SCMI_DOORBELL_C23_INTR_BIT 0
#define SCMI_DOORBELL_C23_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C23_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C23_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C23_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C23_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C23_REG_OFFSET 0x3bc
#define SCMI_COMPLETION_INTERRUPT_C23_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C23_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C24_REG_OFFSET 0x3c0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C24_REG_OFFSET 0x3c4
#define SCMI_CHANNEL_STATUS_C24_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C24_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C24_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C24_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C24_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C24_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C24_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C24_REG_OFFSET 0x3c8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C24_REG_OFFSET 0x3cc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C24_REG_OFFSET 0x3d0
#define SCMI_CHANNEL_FLAGS_C24_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C24_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C24_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C24_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C24_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C24_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C24_REG_OFFSET 0x3d4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C24_REG_OFFSET 0x3d8
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C24_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C24_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C24_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C24_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C24_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C24_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C24_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C24_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C24_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C24_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C24_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C24_REG_OFFSET 0x3dc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C24_REG_OFFSET 0x3e0
#define SCMI_DOORBELL_C24_INTR_BIT 0
#define SCMI_DOORBELL_C24_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C24_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C24_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C24_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C24_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C24_REG_OFFSET 0x3e4
#define SCMI_COMPLETION_INTERRUPT_C24_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C24_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C25_REG_OFFSET 0x3e8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C25_REG_OFFSET 0x3ec
#define SCMI_CHANNEL_STATUS_C25_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C25_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C25_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C25_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C25_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C25_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C25_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C25_REG_OFFSET 0x3f0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C25_REG_OFFSET 0x3f4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C25_REG_OFFSET 0x3f8
#define SCMI_CHANNEL_FLAGS_C25_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C25_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C25_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C25_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C25_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C25_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C25_REG_OFFSET 0x3fc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C25_REG_OFFSET 0x400
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C25_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C25_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C25_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C25_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C25_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C25_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C25_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C25_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C25_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C25_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C25_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C25_REG_OFFSET 0x404

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C25_REG_OFFSET 0x408
#define SCMI_DOORBELL_C25_INTR_BIT 0
#define SCMI_DOORBELL_C25_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C25_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C25_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C25_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C25_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C25_REG_OFFSET 0x40c
#define SCMI_COMPLETION_INTERRUPT_C25_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C25_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C26_REG_OFFSET 0x410

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C26_REG_OFFSET 0x414
#define SCMI_CHANNEL_STATUS_C26_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C26_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C26_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C26_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C26_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C26_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C26_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C26_REG_OFFSET 0x418

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C26_REG_OFFSET 0x41c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C26_REG_OFFSET 0x420
#define SCMI_CHANNEL_FLAGS_C26_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C26_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C26_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C26_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C26_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C26_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C26_REG_OFFSET 0x424

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C26_REG_OFFSET 0x428
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C26_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C26_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C26_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C26_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C26_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C26_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C26_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C26_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C26_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C26_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C26_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C26_REG_OFFSET 0x42c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C26_REG_OFFSET 0x430
#define SCMI_DOORBELL_C26_INTR_BIT 0
#define SCMI_DOORBELL_C26_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C26_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C26_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C26_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C26_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C26_REG_OFFSET 0x434
#define SCMI_COMPLETION_INTERRUPT_C26_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C26_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C27_REG_OFFSET 0x438

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C27_REG_OFFSET 0x43c
#define SCMI_CHANNEL_STATUS_C27_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C27_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C27_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C27_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C27_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C27_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C27_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C27_REG_OFFSET 0x440

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C27_REG_OFFSET 0x444

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C27_REG_OFFSET 0x448
#define SCMI_CHANNEL_FLAGS_C27_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C27_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C27_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C27_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C27_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C27_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C27_REG_OFFSET 0x44c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C27_REG_OFFSET 0x450
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C27_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C27_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C27_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C27_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C27_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C27_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C27_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C27_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C27_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C27_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C27_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C27_REG_OFFSET 0x454

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C27_REG_OFFSET 0x458
#define SCMI_DOORBELL_C27_INTR_BIT 0
#define SCMI_DOORBELL_C27_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C27_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C27_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C27_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C27_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C27_REG_OFFSET 0x45c
#define SCMI_COMPLETION_INTERRUPT_C27_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C27_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C28_REG_OFFSET 0x460

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C28_REG_OFFSET 0x464
#define SCMI_CHANNEL_STATUS_C28_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C28_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C28_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C28_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C28_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C28_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C28_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C28_REG_OFFSET 0x468

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C28_REG_OFFSET 0x46c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C28_REG_OFFSET 0x470
#define SCMI_CHANNEL_FLAGS_C28_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C28_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C28_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C28_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C28_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C28_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C28_REG_OFFSET 0x474

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C28_REG_OFFSET 0x478
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C28_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C28_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C28_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C28_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C28_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C28_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C28_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C28_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C28_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C28_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C28_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C28_REG_OFFSET 0x47c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C28_REG_OFFSET 0x480
#define SCMI_DOORBELL_C28_INTR_BIT 0
#define SCMI_DOORBELL_C28_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C28_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C28_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C28_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C28_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C28_REG_OFFSET 0x484
#define SCMI_COMPLETION_INTERRUPT_C28_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C28_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C29_REG_OFFSET 0x488

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C29_REG_OFFSET 0x48c
#define SCMI_CHANNEL_STATUS_C29_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C29_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C29_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C29_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C29_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C29_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C29_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C29_REG_OFFSET 0x490

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C29_REG_OFFSET 0x494

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C29_REG_OFFSET 0x498
#define SCMI_CHANNEL_FLAGS_C29_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C29_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C29_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C29_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C29_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C29_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C29_REG_OFFSET 0x49c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C29_REG_OFFSET 0x4a0
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C29_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C29_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C29_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C29_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C29_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C29_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C29_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C29_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C29_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C29_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C29_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C29_REG_OFFSET 0x4a4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C29_REG_OFFSET 0x4a8
#define SCMI_DOORBELL_C29_INTR_BIT 0
#define SCMI_DOORBELL_C29_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C29_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C29_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C29_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C29_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C29_REG_OFFSET 0x4ac
#define SCMI_COMPLETION_INTERRUPT_C29_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C29_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C30_REG_OFFSET 0x4b0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C30_REG_OFFSET 0x4b4
#define SCMI_CHANNEL_STATUS_C30_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C30_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C30_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C30_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C30_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C30_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C30_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C30_REG_OFFSET 0x4b8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C30_REG_OFFSET 0x4bc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C30_REG_OFFSET 0x4c0
#define SCMI_CHANNEL_FLAGS_C30_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C30_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C30_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C30_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C30_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C30_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C30_REG_OFFSET 0x4c4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C30_REG_OFFSET 0x4c8
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C30_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C30_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C30_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C30_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C30_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C30_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C30_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C30_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C30_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C30_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C30_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C30_REG_OFFSET 0x4cc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C30_REG_OFFSET 0x4d0
#define SCMI_DOORBELL_C30_INTR_BIT 0
#define SCMI_DOORBELL_C30_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C30_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C30_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C30_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C30_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C30_REG_OFFSET 0x4d4
#define SCMI_COMPLETION_INTERRUPT_C30_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C30_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C31_REG_OFFSET 0x4d8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C31_REG_OFFSET 0x4dc
#define SCMI_CHANNEL_STATUS_C31_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C31_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C31_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C31_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C31_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C31_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C31_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C31_REG_OFFSET 0x4e0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C31_REG_OFFSET 0x4e4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C31_REG_OFFSET 0x4e8
#define SCMI_CHANNEL_FLAGS_C31_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C31_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C31_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C31_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C31_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C31_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C31_REG_OFFSET 0x4ec

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C31_REG_OFFSET 0x4f0
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C31_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C31_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C31_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C31_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C31_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C31_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C31_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C31_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C31_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C31_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C31_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C31_REG_OFFSET 0x4f4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C31_REG_OFFSET 0x4f8
#define SCMI_DOORBELL_C31_INTR_BIT 0
#define SCMI_DOORBELL_C31_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C31_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C31_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C31_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C31_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C31_REG_OFFSET 0x4fc
#define SCMI_COMPLETION_INTERRUPT_C31_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C31_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C32_REG_OFFSET 0x500

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C32_REG_OFFSET 0x504
#define SCMI_CHANNEL_STATUS_C32_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C32_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C32_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C32_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C32_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C32_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C32_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C32_REG_OFFSET 0x508

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C32_REG_OFFSET 0x50c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C32_REG_OFFSET 0x510
#define SCMI_CHANNEL_FLAGS_C32_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C32_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C32_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C32_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C32_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C32_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C32_REG_OFFSET 0x514

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C32_REG_OFFSET 0x518
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C32_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C32_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C32_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C32_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C32_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C32_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C32_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C32_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C32_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C32_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C32_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C32_REG_OFFSET 0x51c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C32_REG_OFFSET 0x520
#define SCMI_DOORBELL_C32_INTR_BIT 0
#define SCMI_DOORBELL_C32_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C32_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C32_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C32_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C32_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C32_REG_OFFSET 0x524
#define SCMI_COMPLETION_INTERRUPT_C32_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C32_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C33_REG_OFFSET 0x528

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C33_REG_OFFSET 0x52c
#define SCMI_CHANNEL_STATUS_C33_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C33_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C33_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C33_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C33_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C33_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C33_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C33_REG_OFFSET 0x530

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C33_REG_OFFSET 0x534

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C33_REG_OFFSET 0x538
#define SCMI_CHANNEL_FLAGS_C33_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C33_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C33_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C33_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C33_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C33_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C33_REG_OFFSET 0x53c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C33_REG_OFFSET 0x540
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C33_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C33_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C33_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C33_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C33_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C33_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C33_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C33_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C33_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C33_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C33_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C33_REG_OFFSET 0x544

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C33_REG_OFFSET 0x548
#define SCMI_DOORBELL_C33_INTR_BIT 0
#define SCMI_DOORBELL_C33_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C33_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C33_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C33_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C33_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C33_REG_OFFSET 0x54c
#define SCMI_COMPLETION_INTERRUPT_C33_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C33_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C34_REG_OFFSET 0x550

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C34_REG_OFFSET 0x554
#define SCMI_CHANNEL_STATUS_C34_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C34_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C34_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C34_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C34_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C34_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C34_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C34_REG_OFFSET 0x558

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C34_REG_OFFSET 0x55c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C34_REG_OFFSET 0x560
#define SCMI_CHANNEL_FLAGS_C34_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C34_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C34_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C34_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C34_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C34_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C34_REG_OFFSET 0x564

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C34_REG_OFFSET 0x568
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C34_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C34_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C34_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C34_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C34_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C34_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C34_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C34_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C34_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C34_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C34_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C34_REG_OFFSET 0x56c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C34_REG_OFFSET 0x570
#define SCMI_DOORBELL_C34_INTR_BIT 0
#define SCMI_DOORBELL_C34_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C34_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C34_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C34_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C34_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C34_REG_OFFSET 0x574
#define SCMI_COMPLETION_INTERRUPT_C34_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C34_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C35_REG_OFFSET 0x578

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C35_REG_OFFSET 0x57c
#define SCMI_CHANNEL_STATUS_C35_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C35_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C35_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C35_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C35_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C35_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C35_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C35_REG_OFFSET 0x580

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C35_REG_OFFSET 0x584

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C35_REG_OFFSET 0x588
#define SCMI_CHANNEL_FLAGS_C35_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C35_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C35_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C35_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C35_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C35_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C35_REG_OFFSET 0x58c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C35_REG_OFFSET 0x590
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C35_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C35_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C35_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C35_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C35_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C35_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C35_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C35_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C35_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C35_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C35_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C35_REG_OFFSET 0x594

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C35_REG_OFFSET 0x598
#define SCMI_DOORBELL_C35_INTR_BIT 0
#define SCMI_DOORBELL_C35_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C35_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C35_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C35_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C35_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C35_REG_OFFSET 0x59c
#define SCMI_COMPLETION_INTERRUPT_C35_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C35_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C36_REG_OFFSET 0x5a0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C36_REG_OFFSET 0x5a4
#define SCMI_CHANNEL_STATUS_C36_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C36_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C36_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C36_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C36_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C36_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C36_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C36_REG_OFFSET 0x5a8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C36_REG_OFFSET 0x5ac

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C36_REG_OFFSET 0x5b0
#define SCMI_CHANNEL_FLAGS_C36_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C36_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C36_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C36_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C36_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C36_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C36_REG_OFFSET 0x5b4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C36_REG_OFFSET 0x5b8
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C36_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C36_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C36_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C36_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C36_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C36_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C36_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C36_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C36_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C36_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C36_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C36_REG_OFFSET 0x5bc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C36_REG_OFFSET 0x5c0
#define SCMI_DOORBELL_C36_INTR_BIT 0
#define SCMI_DOORBELL_C36_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C36_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C36_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C36_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C36_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C36_REG_OFFSET 0x5c4
#define SCMI_COMPLETION_INTERRUPT_C36_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C36_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C37_REG_OFFSET 0x5c8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C37_REG_OFFSET 0x5cc
#define SCMI_CHANNEL_STATUS_C37_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C37_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C37_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C37_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C37_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C37_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C37_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C37_REG_OFFSET 0x5d0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C37_REG_OFFSET 0x5d4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C37_REG_OFFSET 0x5d8
#define SCMI_CHANNEL_FLAGS_C37_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C37_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C37_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C37_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C37_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C37_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C37_REG_OFFSET 0x5dc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C37_REG_OFFSET 0x5e0
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C37_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C37_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C37_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C37_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C37_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C37_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C37_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C37_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C37_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C37_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C37_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C37_REG_OFFSET 0x5e4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C37_REG_OFFSET 0x5e8
#define SCMI_DOORBELL_C37_INTR_BIT 0
#define SCMI_DOORBELL_C37_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C37_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C37_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C37_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C37_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C37_REG_OFFSET 0x5ec
#define SCMI_COMPLETION_INTERRUPT_C37_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C37_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C38_REG_OFFSET 0x5f0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C38_REG_OFFSET 0x5f4
#define SCMI_CHANNEL_STATUS_C38_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C38_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C38_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C38_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C38_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C38_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C38_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C38_REG_OFFSET 0x5f8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C38_REG_OFFSET 0x5fc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C38_REG_OFFSET 0x600
#define SCMI_CHANNEL_FLAGS_C38_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C38_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C38_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C38_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C38_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C38_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C38_REG_OFFSET 0x604

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C38_REG_OFFSET 0x608
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C38_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C38_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C38_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C38_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C38_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C38_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C38_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C38_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C38_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C38_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C38_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C38_REG_OFFSET 0x60c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C38_REG_OFFSET 0x610
#define SCMI_DOORBELL_C38_INTR_BIT 0
#define SCMI_DOORBELL_C38_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C38_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C38_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C38_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C38_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C38_REG_OFFSET 0x614
#define SCMI_COMPLETION_INTERRUPT_C38_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C38_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C39_REG_OFFSET 0x618

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C39_REG_OFFSET 0x61c
#define SCMI_CHANNEL_STATUS_C39_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C39_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C39_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C39_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C39_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C39_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C39_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C39_REG_OFFSET 0x620

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C39_REG_OFFSET 0x624

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C39_REG_OFFSET 0x628
#define SCMI_CHANNEL_FLAGS_C39_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C39_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C39_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C39_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C39_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C39_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C39_REG_OFFSET 0x62c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C39_REG_OFFSET 0x630
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C39_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C39_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C39_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C39_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C39_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C39_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C39_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C39_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C39_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C39_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C39_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C39_REG_OFFSET 0x634

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C39_REG_OFFSET 0x638
#define SCMI_DOORBELL_C39_INTR_BIT 0
#define SCMI_DOORBELL_C39_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C39_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C39_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C39_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C39_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C39_REG_OFFSET 0x63c
#define SCMI_COMPLETION_INTERRUPT_C39_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C39_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C40_REG_OFFSET 0x640

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C40_REG_OFFSET 0x644
#define SCMI_CHANNEL_STATUS_C40_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C40_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C40_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C40_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C40_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C40_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C40_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C40_REG_OFFSET 0x648

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C40_REG_OFFSET 0x64c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C40_REG_OFFSET 0x650
#define SCMI_CHANNEL_FLAGS_C40_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C40_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C40_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C40_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C40_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C40_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C40_REG_OFFSET 0x654

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C40_REG_OFFSET 0x658
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C40_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C40_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C40_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C40_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C40_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C40_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C40_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C40_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C40_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C40_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C40_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C40_REG_OFFSET 0x65c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C40_REG_OFFSET 0x660
#define SCMI_DOORBELL_C40_INTR_BIT 0
#define SCMI_DOORBELL_C40_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C40_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C40_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C40_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C40_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C40_REG_OFFSET 0x664
#define SCMI_COMPLETION_INTERRUPT_C40_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C40_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C41_REG_OFFSET 0x668

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C41_REG_OFFSET 0x66c
#define SCMI_CHANNEL_STATUS_C41_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C41_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C41_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C41_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C41_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C41_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C41_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C41_REG_OFFSET 0x670

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C41_REG_OFFSET 0x674

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C41_REG_OFFSET 0x678
#define SCMI_CHANNEL_FLAGS_C41_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C41_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C41_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C41_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C41_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C41_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C41_REG_OFFSET 0x67c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C41_REG_OFFSET 0x680
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C41_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C41_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C41_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C41_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C41_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C41_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C41_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C41_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C41_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C41_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C41_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C41_REG_OFFSET 0x684

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C41_REG_OFFSET 0x688
#define SCMI_DOORBELL_C41_INTR_BIT 0
#define SCMI_DOORBELL_C41_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C41_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C41_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C41_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C41_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C41_REG_OFFSET 0x68c
#define SCMI_COMPLETION_INTERRUPT_C41_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C41_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C42_REG_OFFSET 0x690

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C42_REG_OFFSET 0x694
#define SCMI_CHANNEL_STATUS_C42_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C42_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C42_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C42_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C42_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C42_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C42_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C42_REG_OFFSET 0x698

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C42_REG_OFFSET 0x69c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C42_REG_OFFSET 0x6a0
#define SCMI_CHANNEL_FLAGS_C42_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C42_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C42_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C42_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C42_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C42_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C42_REG_OFFSET 0x6a4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C42_REG_OFFSET 0x6a8
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C42_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C42_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C42_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C42_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C42_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C42_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C42_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C42_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C42_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C42_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C42_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C42_REG_OFFSET 0x6ac

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C42_REG_OFFSET 0x6b0
#define SCMI_DOORBELL_C42_INTR_BIT 0
#define SCMI_DOORBELL_C42_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C42_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C42_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C42_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C42_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C42_REG_OFFSET 0x6b4
#define SCMI_COMPLETION_INTERRUPT_C42_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C42_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C43_REG_OFFSET 0x6b8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C43_REG_OFFSET 0x6bc
#define SCMI_CHANNEL_STATUS_C43_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C43_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C43_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C43_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C43_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C43_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C43_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C43_REG_OFFSET 0x6c0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C43_REG_OFFSET 0x6c4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C43_REG_OFFSET 0x6c8
#define SCMI_CHANNEL_FLAGS_C43_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C43_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C43_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C43_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C43_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C43_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C43_REG_OFFSET 0x6cc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C43_REG_OFFSET 0x6d0
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C43_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C43_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C43_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C43_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C43_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C43_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C43_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C43_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C43_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C43_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C43_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C43_REG_OFFSET 0x6d4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C43_REG_OFFSET 0x6d8
#define SCMI_DOORBELL_C43_INTR_BIT 0
#define SCMI_DOORBELL_C43_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C43_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C43_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C43_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C43_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C43_REG_OFFSET 0x6dc
#define SCMI_COMPLETION_INTERRUPT_C43_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C43_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C44_REG_OFFSET 0x6e0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C44_REG_OFFSET 0x6e4
#define SCMI_CHANNEL_STATUS_C44_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C44_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C44_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C44_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C44_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C44_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C44_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C44_REG_OFFSET 0x6e8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C44_REG_OFFSET 0x6ec

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C44_REG_OFFSET 0x6f0
#define SCMI_CHANNEL_FLAGS_C44_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C44_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C44_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C44_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C44_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C44_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C44_REG_OFFSET 0x6f4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C44_REG_OFFSET 0x6f8
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C44_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C44_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C44_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C44_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C44_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C44_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C44_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C44_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C44_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C44_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C44_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C44_REG_OFFSET 0x6fc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C44_REG_OFFSET 0x700
#define SCMI_DOORBELL_C44_INTR_BIT 0
#define SCMI_DOORBELL_C44_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C44_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C44_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C44_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C44_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C44_REG_OFFSET 0x704
#define SCMI_COMPLETION_INTERRUPT_C44_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C44_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C45_REG_OFFSET 0x708

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C45_REG_OFFSET 0x70c
#define SCMI_CHANNEL_STATUS_C45_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C45_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C45_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C45_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C45_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C45_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C45_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C45_REG_OFFSET 0x710

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C45_REG_OFFSET 0x714

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C45_REG_OFFSET 0x718
#define SCMI_CHANNEL_FLAGS_C45_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C45_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C45_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C45_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C45_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C45_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C45_REG_OFFSET 0x71c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C45_REG_OFFSET 0x720
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C45_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C45_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C45_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C45_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C45_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C45_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C45_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C45_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C45_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C45_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C45_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C45_REG_OFFSET 0x724

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C45_REG_OFFSET 0x728
#define SCMI_DOORBELL_C45_INTR_BIT 0
#define SCMI_DOORBELL_C45_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C45_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C45_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C45_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C45_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C45_REG_OFFSET 0x72c
#define SCMI_COMPLETION_INTERRUPT_C45_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C45_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C46_REG_OFFSET 0x730

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C46_REG_OFFSET 0x734
#define SCMI_CHANNEL_STATUS_C46_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C46_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C46_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C46_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C46_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C46_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C46_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C46_REG_OFFSET 0x738

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C46_REG_OFFSET 0x73c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C46_REG_OFFSET 0x740
#define SCMI_CHANNEL_FLAGS_C46_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C46_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C46_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C46_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C46_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C46_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C46_REG_OFFSET 0x744

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C46_REG_OFFSET 0x748
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C46_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C46_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C46_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C46_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C46_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C46_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C46_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C46_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C46_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C46_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C46_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C46_REG_OFFSET 0x74c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C46_REG_OFFSET 0x750
#define SCMI_DOORBELL_C46_INTR_BIT 0
#define SCMI_DOORBELL_C46_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C46_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C46_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C46_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C46_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C46_REG_OFFSET 0x754
#define SCMI_COMPLETION_INTERRUPT_C46_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C46_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C47_REG_OFFSET 0x758

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C47_REG_OFFSET 0x75c
#define SCMI_CHANNEL_STATUS_C47_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C47_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C47_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C47_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C47_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C47_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C47_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C47_REG_OFFSET 0x760

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C47_REG_OFFSET 0x764

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C47_REG_OFFSET 0x768
#define SCMI_CHANNEL_FLAGS_C47_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C47_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C47_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C47_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C47_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C47_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C47_REG_OFFSET 0x76c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C47_REG_OFFSET 0x770
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C47_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C47_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C47_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C47_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C47_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C47_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C47_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C47_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C47_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C47_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C47_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C47_REG_OFFSET 0x774

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C47_REG_OFFSET 0x778
#define SCMI_DOORBELL_C47_INTR_BIT 0
#define SCMI_DOORBELL_C47_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C47_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C47_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C47_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C47_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C47_REG_OFFSET 0x77c
#define SCMI_COMPLETION_INTERRUPT_C47_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C47_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C48_REG_OFFSET 0x780

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C48_REG_OFFSET 0x784
#define SCMI_CHANNEL_STATUS_C48_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C48_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C48_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C48_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C48_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C48_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C48_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C48_REG_OFFSET 0x788

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C48_REG_OFFSET 0x78c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C48_REG_OFFSET 0x790
#define SCMI_CHANNEL_FLAGS_C48_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C48_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C48_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C48_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C48_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C48_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C48_REG_OFFSET 0x794

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C48_REG_OFFSET 0x798
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C48_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C48_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C48_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C48_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C48_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C48_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C48_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C48_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C48_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C48_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C48_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C48_REG_OFFSET 0x79c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C48_REG_OFFSET 0x7a0
#define SCMI_DOORBELL_C48_INTR_BIT 0
#define SCMI_DOORBELL_C48_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C48_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C48_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C48_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C48_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C48_REG_OFFSET 0x7a4
#define SCMI_COMPLETION_INTERRUPT_C48_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C48_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C49_REG_OFFSET 0x7a8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C49_REG_OFFSET 0x7ac
#define SCMI_CHANNEL_STATUS_C49_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C49_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C49_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C49_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C49_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C49_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C49_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C49_REG_OFFSET 0x7b0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C49_REG_OFFSET 0x7b4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C49_REG_OFFSET 0x7b8
#define SCMI_CHANNEL_FLAGS_C49_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C49_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C49_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C49_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C49_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C49_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C49_REG_OFFSET 0x7bc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C49_REG_OFFSET 0x7c0
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C49_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C49_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C49_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C49_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C49_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C49_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C49_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C49_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C49_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C49_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C49_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C49_REG_OFFSET 0x7c4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C49_REG_OFFSET 0x7c8
#define SCMI_DOORBELL_C49_INTR_BIT 0
#define SCMI_DOORBELL_C49_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C49_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C49_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C49_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C49_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C49_REG_OFFSET 0x7cc
#define SCMI_COMPLETION_INTERRUPT_C49_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C49_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C50_REG_OFFSET 0x7d0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C50_REG_OFFSET 0x7d4
#define SCMI_CHANNEL_STATUS_C50_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C50_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C50_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C50_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C50_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C50_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C50_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C50_REG_OFFSET 0x7d8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C50_REG_OFFSET 0x7dc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C50_REG_OFFSET 0x7e0
#define SCMI_CHANNEL_FLAGS_C50_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C50_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C50_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C50_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C50_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C50_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C50_REG_OFFSET 0x7e4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C50_REG_OFFSET 0x7e8
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C50_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C50_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C50_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C50_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C50_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C50_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C50_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C50_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C50_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C50_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C50_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C50_REG_OFFSET 0x7ec

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C50_REG_OFFSET 0x7f0
#define SCMI_DOORBELL_C50_INTR_BIT 0
#define SCMI_DOORBELL_C50_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C50_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C50_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C50_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C50_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C50_REG_OFFSET 0x7f4
#define SCMI_COMPLETION_INTERRUPT_C50_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C50_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C51_REG_OFFSET 0x7f8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C51_REG_OFFSET 0x7fc
#define SCMI_CHANNEL_STATUS_C51_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C51_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C51_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C51_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C51_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C51_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C51_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C51_REG_OFFSET 0x800

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C51_REG_OFFSET 0x804

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C51_REG_OFFSET 0x808
#define SCMI_CHANNEL_FLAGS_C51_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C51_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C51_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C51_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C51_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C51_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C51_REG_OFFSET 0x80c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C51_REG_OFFSET 0x810
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C51_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C51_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C51_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C51_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C51_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C51_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C51_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C51_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C51_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C51_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C51_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C51_REG_OFFSET 0x814

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C51_REG_OFFSET 0x818
#define SCMI_DOORBELL_C51_INTR_BIT 0
#define SCMI_DOORBELL_C51_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C51_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C51_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C51_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C51_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C51_REG_OFFSET 0x81c
#define SCMI_COMPLETION_INTERRUPT_C51_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C51_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C52_REG_OFFSET 0x820

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C52_REG_OFFSET 0x824
#define SCMI_CHANNEL_STATUS_C52_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C52_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C52_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C52_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C52_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C52_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C52_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C52_REG_OFFSET 0x828

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C52_REG_OFFSET 0x82c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C52_REG_OFFSET 0x830
#define SCMI_CHANNEL_FLAGS_C52_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C52_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C52_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C52_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C52_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C52_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C52_REG_OFFSET 0x834

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C52_REG_OFFSET 0x838
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C52_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C52_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C52_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C52_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C52_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C52_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C52_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C52_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C52_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C52_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C52_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C52_REG_OFFSET 0x83c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C52_REG_OFFSET 0x840
#define SCMI_DOORBELL_C52_INTR_BIT 0
#define SCMI_DOORBELL_C52_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C52_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C52_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C52_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C52_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C52_REG_OFFSET 0x844
#define SCMI_COMPLETION_INTERRUPT_C52_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C52_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C53_REG_OFFSET 0x848

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C53_REG_OFFSET 0x84c
#define SCMI_CHANNEL_STATUS_C53_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C53_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C53_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C53_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C53_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C53_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C53_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C53_REG_OFFSET 0x850

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C53_REG_OFFSET 0x854

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C53_REG_OFFSET 0x858
#define SCMI_CHANNEL_FLAGS_C53_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C53_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C53_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C53_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C53_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C53_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C53_REG_OFFSET 0x85c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C53_REG_OFFSET 0x860
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C53_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C53_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C53_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C53_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C53_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C53_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C53_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C53_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C53_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C53_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C53_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C53_REG_OFFSET 0x864

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C53_REG_OFFSET 0x868
#define SCMI_DOORBELL_C53_INTR_BIT 0
#define SCMI_DOORBELL_C53_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C53_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C53_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C53_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C53_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C53_REG_OFFSET 0x86c
#define SCMI_COMPLETION_INTERRUPT_C53_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C53_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C54_REG_OFFSET 0x870

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C54_REG_OFFSET 0x874
#define SCMI_CHANNEL_STATUS_C54_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C54_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C54_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C54_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C54_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C54_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C54_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C54_REG_OFFSET 0x878

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C54_REG_OFFSET 0x87c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C54_REG_OFFSET 0x880
#define SCMI_CHANNEL_FLAGS_C54_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C54_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C54_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C54_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C54_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C54_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C54_REG_OFFSET 0x884

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C54_REG_OFFSET 0x888
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C54_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C54_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C54_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C54_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C54_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C54_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C54_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C54_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C54_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C54_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C54_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C54_REG_OFFSET 0x88c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C54_REG_OFFSET 0x890
#define SCMI_DOORBELL_C54_INTR_BIT 0
#define SCMI_DOORBELL_C54_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C54_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C54_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C54_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C54_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C54_REG_OFFSET 0x894
#define SCMI_COMPLETION_INTERRUPT_C54_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C54_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C55_REG_OFFSET 0x898

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C55_REG_OFFSET 0x89c
#define SCMI_CHANNEL_STATUS_C55_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C55_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C55_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C55_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C55_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C55_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C55_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C55_REG_OFFSET 0x8a0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C55_REG_OFFSET 0x8a4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C55_REG_OFFSET 0x8a8
#define SCMI_CHANNEL_FLAGS_C55_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C55_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C55_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C55_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C55_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C55_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C55_REG_OFFSET 0x8ac

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C55_REG_OFFSET 0x8b0
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C55_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C55_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C55_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C55_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C55_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C55_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C55_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C55_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C55_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C55_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C55_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C55_REG_OFFSET 0x8b4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C55_REG_OFFSET 0x8b8
#define SCMI_DOORBELL_C55_INTR_BIT 0
#define SCMI_DOORBELL_C55_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C55_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C55_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C55_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C55_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C55_REG_OFFSET 0x8bc
#define SCMI_COMPLETION_INTERRUPT_C55_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C55_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C56_REG_OFFSET 0x8c0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C56_REG_OFFSET 0x8c4
#define SCMI_CHANNEL_STATUS_C56_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C56_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C56_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C56_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C56_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C56_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C56_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C56_REG_OFFSET 0x8c8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C56_REG_OFFSET 0x8cc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C56_REG_OFFSET 0x8d0
#define SCMI_CHANNEL_FLAGS_C56_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C56_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C56_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C56_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C56_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C56_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C56_REG_OFFSET 0x8d4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C56_REG_OFFSET 0x8d8
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C56_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C56_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C56_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C56_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C56_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C56_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C56_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C56_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C56_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C56_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C56_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C56_REG_OFFSET 0x8dc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C56_REG_OFFSET 0x8e0
#define SCMI_DOORBELL_C56_INTR_BIT 0
#define SCMI_DOORBELL_C56_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C56_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C56_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C56_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C56_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C56_REG_OFFSET 0x8e4
#define SCMI_COMPLETION_INTERRUPT_C56_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C56_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C57_REG_OFFSET 0x8e8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C57_REG_OFFSET 0x8ec
#define SCMI_CHANNEL_STATUS_C57_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C57_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C57_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C57_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C57_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C57_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C57_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C57_REG_OFFSET 0x8f0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C57_REG_OFFSET 0x8f4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C57_REG_OFFSET 0x8f8
#define SCMI_CHANNEL_FLAGS_C57_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C57_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C57_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C57_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C57_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C57_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C57_REG_OFFSET 0x8fc

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C57_REG_OFFSET 0x900
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C57_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C57_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C57_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C57_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C57_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C57_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C57_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C57_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C57_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C57_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C57_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C57_REG_OFFSET 0x904

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C57_REG_OFFSET 0x908
#define SCMI_DOORBELL_C57_INTR_BIT 0
#define SCMI_DOORBELL_C57_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C57_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C57_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C57_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C57_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C57_REG_OFFSET 0x90c
#define SCMI_COMPLETION_INTERRUPT_C57_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C57_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C58_REG_OFFSET 0x910

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C58_REG_OFFSET 0x914
#define SCMI_CHANNEL_STATUS_C58_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C58_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C58_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C58_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C58_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C58_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C58_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C58_REG_OFFSET 0x918

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C58_REG_OFFSET 0x91c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C58_REG_OFFSET 0x920
#define SCMI_CHANNEL_FLAGS_C58_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C58_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C58_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C58_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C58_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C58_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C58_REG_OFFSET 0x924

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C58_REG_OFFSET 0x928
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C58_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C58_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C58_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C58_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C58_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C58_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C58_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C58_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C58_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C58_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C58_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C58_REG_OFFSET 0x92c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C58_REG_OFFSET 0x930
#define SCMI_DOORBELL_C58_INTR_BIT 0
#define SCMI_DOORBELL_C58_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C58_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C58_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C58_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C58_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C58_REG_OFFSET 0x934
#define SCMI_COMPLETION_INTERRUPT_C58_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C58_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C59_REG_OFFSET 0x938

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C59_REG_OFFSET 0x93c
#define SCMI_CHANNEL_STATUS_C59_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C59_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C59_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C59_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C59_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C59_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C59_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C59_REG_OFFSET 0x940

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C59_REG_OFFSET 0x944

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C59_REG_OFFSET 0x948
#define SCMI_CHANNEL_FLAGS_C59_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C59_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C59_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C59_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C59_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C59_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C59_REG_OFFSET 0x94c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C59_REG_OFFSET 0x950
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C59_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C59_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C59_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C59_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C59_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C59_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C59_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C59_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C59_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C59_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C59_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C59_REG_OFFSET 0x954

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C59_REG_OFFSET 0x958
#define SCMI_DOORBELL_C59_INTR_BIT 0
#define SCMI_DOORBELL_C59_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C59_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C59_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C59_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C59_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C59_REG_OFFSET 0x95c
#define SCMI_COMPLETION_INTERRUPT_C59_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C59_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C60_REG_OFFSET 0x960

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C60_REG_OFFSET 0x964
#define SCMI_CHANNEL_STATUS_C60_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C60_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C60_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C60_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C60_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C60_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C60_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C60_REG_OFFSET 0x968

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C60_REG_OFFSET 0x96c

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C60_REG_OFFSET 0x970
#define SCMI_CHANNEL_FLAGS_C60_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C60_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C60_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C60_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C60_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C60_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C60_REG_OFFSET 0x974

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C60_REG_OFFSET 0x978
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C60_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C60_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C60_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C60_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C60_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C60_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C60_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C60_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C60_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C60_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C60_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C60_REG_OFFSET 0x97c

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C60_REG_OFFSET 0x980
#define SCMI_DOORBELL_C60_INTR_BIT 0
#define SCMI_DOORBELL_C60_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C60_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C60_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C60_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C60_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C60_REG_OFFSET 0x984
#define SCMI_COMPLETION_INTERRUPT_C60_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C60_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C61_REG_OFFSET 0x988

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C61_REG_OFFSET 0x98c
#define SCMI_CHANNEL_STATUS_C61_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C61_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C61_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C61_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C61_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C61_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C61_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C61_REG_OFFSET 0x990

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C61_REG_OFFSET 0x994

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C61_REG_OFFSET 0x998
#define SCMI_CHANNEL_FLAGS_C61_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C61_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C61_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C61_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C61_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C61_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C61_REG_OFFSET 0x99c

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C61_REG_OFFSET 0x9a0
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C61_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C61_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C61_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C61_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C61_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C61_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C61_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C61_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C61_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C61_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C61_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C61_REG_OFFSET 0x9a4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C61_REG_OFFSET 0x9a8
#define SCMI_DOORBELL_C61_INTR_BIT 0
#define SCMI_DOORBELL_C61_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C61_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C61_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C61_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C61_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C61_REG_OFFSET 0x9ac
#define SCMI_COMPLETION_INTERRUPT_C61_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C61_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C62_REG_OFFSET 0x9b0

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C62_REG_OFFSET 0x9b4
#define SCMI_CHANNEL_STATUS_C62_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C62_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C62_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C62_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C62_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C62_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C62_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C62_REG_OFFSET 0x9b8

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C62_REG_OFFSET 0x9bc

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C62_REG_OFFSET 0x9c0
#define SCMI_CHANNEL_FLAGS_C62_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C62_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C62_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C62_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C62_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C62_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C62_REG_OFFSET 0x9c4

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C62_REG_OFFSET 0x9c8
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C62_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C62_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C62_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C62_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C62_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C62_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C62_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C62_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C62_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C62_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C62_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C62_REG_OFFSET 0x9cc

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C62_REG_OFFSET 0x9d0
#define SCMI_DOORBELL_C62_INTR_BIT 0
#define SCMI_DOORBELL_C62_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C62_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C62_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C62_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C62_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C62_REG_OFFSET 0x9d4
#define SCMI_COMPLETION_INTERRUPT_C62_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C62_PRESERVE_MASK_OFFSET })

// Reserved, must be 0
#define SCMI_RESERVED_1_C63_REG_OFFSET 0x9d8

// Indicates which entity has access to the Shared Memory
#define SCMI_CHANNEL_STATUS_C63_REG_OFFSET 0x9dc
#define SCMI_CHANNEL_STATUS_C63_CHANNEL_FREE_BIT 0
#define SCMI_CHANNEL_STATUS_C63_CHANNEL_ERROR_BIT 1
#define SCMI_CHANNEL_STATUS_C63_FIELD1_MASK 0x3fffffff
#define SCMI_CHANNEL_STATUS_C63_FIELD1_OFFSET 2
#define SCMI_CHANNEL_STATUS_C63_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_STATUS_C63_FIELD1_MASK, .index = SCMI_CHANNEL_STATUS_C63_FIELD1_OFFSET })

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_2_C63_REG_OFFSET 0x9e0

// Reserved, implementation defined (32 bits over 64)
#define SCMI_RESERVED_3_C63_REG_OFFSET 0x9e4

// Defines wheter interrupts or polling is used for communication
#define SCMI_CHANNEL_FLAGS_C63_REG_OFFSET 0x9e8
#define SCMI_CHANNEL_FLAGS_C63_INTR_ENABLE_BIT 0
#define SCMI_CHANNEL_FLAGS_C63_FIELD1_MASK 0x7fffffff
#define SCMI_CHANNEL_FLAGS_C63_FIELD1_OFFSET 1
#define SCMI_CHANNEL_FLAGS_C63_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_CHANNEL_FLAGS_C63_FIELD1_MASK, .index = SCMI_CHANNEL_FLAGS_C63_FIELD1_OFFSET })

// Lenght of payload + header
#define SCMI_LENGTH_C63_REG_OFFSET 0x9ec

// Defines which commanad the message contains
#define SCMI_MESSAGE_HEADER_C63_REG_OFFSET 0x9f0
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_OFFSET 0
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_MASK, .index = SCMI_MESSAGE_HEADER_C63_MESSAGE_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_MASK 0x3
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_OFFSET 8
#define SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_MASK, .index = SCMI_MESSAGE_HEADER_C63_MESSAGE_TYPE_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_MASK 0xff
#define SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_OFFSET 10
#define SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_MASK, .index = SCMI_MESSAGE_HEADER_C63_PROTOCOL_ID_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_TOKEN_MASK 0x3ff
#define SCMI_MESSAGE_HEADER_C63_TOKEN_OFFSET 18
#define SCMI_MESSAGE_HEADER_C63_TOKEN_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_TOKEN_MASK, .index = SCMI_MESSAGE_HEADER_C63_TOKEN_OFFSET })
#define SCMI_MESSAGE_HEADER_C63_FIELD1_MASK 0xf
#define SCMI_MESSAGE_HEADER_C63_FIELD1_OFFSET 28
#define SCMI_MESSAGE_HEADER_C63_FIELD1_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_MESSAGE_HEADER_C63_FIELD1_MASK, .index = SCMI_MESSAGE_HEADER_C63_FIELD1_OFFSET })

// memory region dedicated to the parameters of the commands and their
// returns
#define SCMI_MESSAGE_PAYLOAD_1_C63_REG_OFFSET 0x9f4

// Rapresents the interrupt to be raised towards the platform
#define SCMI_DOORBELL_C63_REG_OFFSET 0x9f8
#define SCMI_DOORBELL_C63_INTR_BIT 0
#define SCMI_DOORBELL_C63_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_DOORBELL_C63_PRESERVE_MASK_OFFSET 1
#define SCMI_DOORBELL_C63_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_DOORBELL_C63_PRESERVE_MASK_MASK, .index = SCMI_DOORBELL_C63_PRESERVE_MASK_OFFSET })

// Rapresent the interrupt the platform should raise when it finishes to
// execute the received command
#define SCMI_COMPLETION_INTERRUPT_C63_REG_OFFSET 0x9fc
#define SCMI_COMPLETION_INTERRUPT_C63_INTR_BIT 0
#define SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_MASK 0x7fffffff
#define SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_OFFSET 1
#define SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_FIELD \
  ((bitfield_field32_t) { .mask = SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_MASK, .index = SCMI_COMPLETION_INTERRUPT_C63_PRESERVE_MASK_OFFSET })

#ifdef __cplusplus
}  // extern "C"
#endif
#endif  // _SCMI_REG_DEFS_
// End generated register defines for scmi